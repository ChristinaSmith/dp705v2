//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Tue Oct 16 11:00:15 EDT 2012
//
// Method conflict info:
// Method: src_get
// Conflict-free: sink_put, newLen_put, getLen_dwm, giveLen_get
// Conflicts: src_get
//
// Method: sink_put
// Conflict-free: src_get, newLen_put, getLen_dwm, giveLen_get
// Conflicts: sink_put
//
// Method: newLen_put
// Conflict-free: src_get, sink_put, getLen_dwm, giveLen_get
// Conflicts: newLen_put
//
// Method: getLen_dwm
// Conflict-free: src_get, sink_put, newLen_put, getLen_dwm, giveLen_get
//
// Method: giveLen_get
// Conflict-free: src_get, sink_put, newLen_put, getLen_dwm
// Conflicts: giveLen_get
//
//
// Ports:
// Name                         I/O  size props
// src_get                        O    33 reg
// RDY_src_get                    O     1 reg
// RDY_sink_put                   O     1 reg
// RDY_newLen_put                 O     1 reg
// getLen_dwm                     O     1 reg
// RDY_getLen_dwm                 O     1 const
// giveLen_get                    O     9 reg
// RDY_giveLen_get                O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// sink_put                       I    33 reg
// newLen_put                     I     9 reg
// EN_sink_put                    I     1
// EN_newLen_put                  I     1
// EN_src_get                     I     1
// EN_giveLen_get                 I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMHSender(CLK,
		  RST_N,

		  EN_src_get,
		  src_get,
		  RDY_src_get,

		  sink_put,
		  EN_sink_put,
		  RDY_sink_put,

		  newLen_put,
		  EN_newLen_put,
		  RDY_newLen_put,

		  getLen_dwm,
		  RDY_getLen_dwm,

		  EN_giveLen_get,
		  giveLen_get,
		  RDY_giveLen_get);
  input  CLK;
  input  RST_N;

  // actionvalue method src_get
  input  EN_src_get;
  output [32 : 0] src_get;
  output RDY_src_get;

  // action method sink_put
  input  [32 : 0] sink_put;
  input  EN_sink_put;
  output RDY_sink_put;

  // action method newLen_put
  input  [8 : 0] newLen_put;
  input  EN_newLen_put;
  output RDY_newLen_put;

  // value method getLen_dwm
  output getLen_dwm;
  output RDY_getLen_dwm;

  // actionvalue method giveLen_get
  input  EN_giveLen_get;
  output [8 : 0] giveLen_get;
  output RDY_giveLen_get;

  // signals for module outputs
  wire [32 : 0] src_get;
  wire [8 : 0] giveLen_get;
  wire RDY_getLen_dwm,
       RDY_giveLen_get,
       RDY_newLen_put,
       RDY_sink_put,
       RDY_src_get,
       getLen_dwm;

  // register eopR
  reg eopR;
  wire eopR$D_IN, eopR$EN;

  // register fragLenCnt
  reg [8 : 0] fragLenCnt;
  wire [8 : 0] fragLenCnt$D_IN;
  wire fragLenCnt$EN;

  // register hp
  reg [8 : 0] hp;
  wire [8 : 0] hp$D_IN;
  wire hp$EN;

  // register lenR
  reg [9 : 0] lenR;
  wire [9 : 0] lenR$D_IN;
  wire lenR$EN;

  // register mhV
  reg [32 : 0] mhV;
  wire [32 : 0] mhV$D_IN;
  wire mhV$EN;

  // register mhV_1
  reg [32 : 0] mhV_1;
  wire [32 : 0] mhV_1$D_IN;
  wire mhV_1$EN;

  // register mhV_2
  reg [32 : 0] mhV_2;
  wire [32 : 0] mhV_2$D_IN;
  wire mhV_2$EN;

  // register mhV_3
  reg [32 : 0] mhV_3;
  wire [32 : 0] mhV_3$D_IN;
  wire mhV_3$EN;

  // register mhV_4
  reg [32 : 0] mhV_4;
  wire [32 : 0] mhV_4$D_IN;
  wire mhV_4$EN;

  // register mhV_5
  reg [32 : 0] mhV_5;
  wire [32 : 0] mhV_5$D_IN;
  wire mhV_5$EN;

  // register msgHeadLen
  reg [8 : 0] msgHeadLen;
  wire [8 : 0] msgHeadLen$D_IN;
  wire msgHeadLen$EN;

  // ports of submodule headerF
  wire headerF$CLR, headerF$DEQ, headerF$EMPTY_N, headerF$ENQ, headerF$FULL_N;

  // ports of submodule lenToFHF
  wire [8 : 0] lenToFHF$D_IN, lenToFHF$D_OUT;
  wire lenToFHF$CLR, lenToFHF$DEQ, lenToFHF$EMPTY_N, lenToFHF$ENQ;

  // ports of submodule lengthF
  wire [8 : 0] lengthF$D_IN, lengthF$D_OUT;
  wire lengthF$CLR, lengthF$DEQ, lengthF$EMPTY_N, lengthF$ENQ, lengthF$FULL_N;

  // ports of submodule mesgInF
  wire [32 : 0] mesgInF$D_IN, mesgInF$D_OUT;
  wire mesgInF$CLR, mesgInF$DEQ, mesgInF$EMPTY_N, mesgInF$ENQ, mesgInF$FULL_N;

  // ports of submodule mesgOutF
  wire [32 : 0] mesgOutF$D_IN, mesgOutF$D_OUT;
  wire mesgOutF$CLR,
       mesgOutF$DEQ,
       mesgOutF$EMPTY_N,
       mesgOutF$ENQ,
       mesgOutF$FULL_N;

  // ports of submodule messageF
  wire messageF$CLR,
       messageF$DEQ,
       messageF$EMPTY_N,
       messageF$ENQ,
       messageF$FULL_N;

  // ports of submodule msgDoneF
  wire msgDoneF$CLR, msgDoneF$DEQ, msgDoneF$ENQ;

  // rule scheduling signals
  wire CAN_FIRE_RL_eopR__dreg_update,
       CAN_FIRE_RL_popMhV,
       CAN_FIRE_RL_sndHead,
       CAN_FIRE_RL_sndMesg,
       CAN_FIRE_giveLen_get,
       CAN_FIRE_newLen_put,
       CAN_FIRE_sink_put,
       CAN_FIRE_src_get,
       WILL_FIRE_RL_eopR__dreg_update,
       WILL_FIRE_RL_popMhV,
       WILL_FIRE_RL_sndHead,
       WILL_FIRE_RL_sndMesg,
       WILL_FIRE_giveLen_get,
       WILL_FIRE_newLen_put,
       WILL_FIRE_sink_put,
       WILL_FIRE_src_get;

  // inputs to muxes for submodule ports
  reg [32 : 0] MUX_mesgOutF$enq_1__VAL_1;

  // remaining internal signals
  wire hp_4_EQ_msgHeadLen_5___d73,
       mesgOutF_i_notFull__3_AND_NOT_hp_4_EQ_msgHeadL_ETC___d22;

  // actionvalue method src_get
  assign src_get = mesgOutF$D_OUT ;
  assign RDY_src_get = mesgOutF$EMPTY_N ;
  assign CAN_FIRE_src_get = mesgOutF$EMPTY_N ;
  assign WILL_FIRE_src_get = EN_src_get ;

  // action method sink_put
  assign RDY_sink_put = mesgInF$FULL_N ;
  assign CAN_FIRE_sink_put = mesgInF$FULL_N ;
  assign WILL_FIRE_sink_put = EN_sink_put ;

  // action method newLen_put
  assign RDY_newLen_put = lengthF$FULL_N ;
  assign CAN_FIRE_newLen_put = lengthF$FULL_N ;
  assign WILL_FIRE_newLen_put = EN_newLen_put ;

  // value method getLen_dwm
  assign getLen_dwm = eopR ;
  assign RDY_getLen_dwm = 1'd1 ;

  // actionvalue method giveLen_get
  assign giveLen_get = lenToFHF$D_OUT ;
  assign RDY_giveLen_get = lenToFHF$EMPTY_N ;
  assign CAN_FIRE_giveLen_get = lenToFHF$EMPTY_N ;
  assign WILL_FIRE_giveLen_get = EN_giveLen_get ;

  // submodule headerF
  FIFO20 #(.guarded(32'd1)) headerF(.RST(RST_N),
				    .CLK(CLK),
				    .ENQ(headerF$ENQ),
				    .DEQ(headerF$DEQ),
				    .CLR(headerF$CLR),
				    .FULL_N(headerF$FULL_N),
				    .EMPTY_N(headerF$EMPTY_N));

  // submodule lenToFHF
  FIFO2 #(.width(32'd9), .guarded(32'd1)) lenToFHF(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(lenToFHF$D_IN),
						   .ENQ(lenToFHF$ENQ),
						   .DEQ(lenToFHF$DEQ),
						   .CLR(lenToFHF$CLR),
						   .D_OUT(lenToFHF$D_OUT),
						   .FULL_N(),
						   .EMPTY_N(lenToFHF$EMPTY_N));

  // submodule lengthF
  FIFO2 #(.width(32'd9), .guarded(32'd1)) lengthF(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(lengthF$D_IN),
						  .ENQ(lengthF$ENQ),
						  .DEQ(lengthF$DEQ),
						  .CLR(lengthF$CLR),
						  .D_OUT(lengthF$D_OUT),
						  .FULL_N(lengthF$FULL_N),
						  .EMPTY_N(lengthF$EMPTY_N));

  // submodule mesgInF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) mesgInF(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(mesgInF$D_IN),
						   .ENQ(mesgInF$ENQ),
						   .DEQ(mesgInF$DEQ),
						   .CLR(mesgInF$CLR),
						   .D_OUT(mesgInF$D_OUT),
						   .FULL_N(mesgInF$FULL_N),
						   .EMPTY_N(mesgInF$EMPTY_N));

  // submodule mesgOutF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) mesgOutF(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(mesgOutF$D_IN),
						    .ENQ(mesgOutF$ENQ),
						    .DEQ(mesgOutF$DEQ),
						    .CLR(mesgOutF$CLR),
						    .D_OUT(mesgOutF$D_OUT),
						    .FULL_N(mesgOutF$FULL_N),
						    .EMPTY_N(mesgOutF$EMPTY_N));

  // submodule messageF
  FIFO20 #(.guarded(32'd1)) messageF(.RST(RST_N),
				     .CLK(CLK),
				     .ENQ(messageF$ENQ),
				     .DEQ(messageF$DEQ),
				     .CLR(messageF$CLR),
				     .FULL_N(messageF$FULL_N),
				     .EMPTY_N(messageF$EMPTY_N));

  // submodule msgDoneF
  FIFO20 #(.guarded(32'd1)) msgDoneF(.RST(RST_N),
				     .CLK(CLK),
				     .ENQ(msgDoneF$ENQ),
				     .DEQ(msgDoneF$DEQ),
				     .CLR(msgDoneF$CLR),
				     .FULL_N(),
				     .EMPTY_N());

  // rule RL_sndHead
  assign CAN_FIRE_RL_sndHead =
	     mesgOutF_i_notFull__3_AND_NOT_hp_4_EQ_msgHeadL_ETC___d22 &&
	     headerF$EMPTY_N ;
  assign WILL_FIRE_RL_sndHead = CAN_FIRE_RL_sndHead ;

  // rule RL_popMhV
  assign CAN_FIRE_RL_popMhV = lengthF$EMPTY_N && headerF$FULL_N ;
  assign WILL_FIRE_RL_popMhV = CAN_FIRE_RL_popMhV ;

  // rule RL_sndMesg
  assign CAN_FIRE_RL_sndMesg =
	     mesgOutF$FULL_N && mesgInF$EMPTY_N &&
	     (!mesgInF$D_OUT[32] || messageF$EMPTY_N) &&
	     messageF$EMPTY_N ;
  assign WILL_FIRE_RL_sndMesg = CAN_FIRE_RL_sndMesg && !WILL_FIRE_RL_sndHead ;

  // rule RL_eopR__dreg_update
  assign CAN_FIRE_RL_eopR__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_eopR__dreg_update = 1'd1 ;

  // inputs to muxes for submodule ports
  always@(hp or mhV_5 or mhV or mhV_1 or mhV_2 or mhV_3 or mhV_4)
  begin
    case (hp)
      9'd0: MUX_mesgOutF$enq_1__VAL_1 = mhV;
      9'd1: MUX_mesgOutF$enq_1__VAL_1 = mhV_1;
      9'd2: MUX_mesgOutF$enq_1__VAL_1 = mhV_2;
      9'd3: MUX_mesgOutF$enq_1__VAL_1 = mhV_3;
      9'd4: MUX_mesgOutF$enq_1__VAL_1 = mhV_4;
      default: MUX_mesgOutF$enq_1__VAL_1 =
		   { hp != 9'd5 || mhV_5[32], mhV_5[31:0] };
    endcase
  end

  // register eopR
  assign eopR$D_IN = WILL_FIRE_RL_sndMesg && mesgInF$D_OUT[32] ;
  assign eopR$EN = 1'd1 ;

  // register fragLenCnt
  assign fragLenCnt$D_IN = 9'h0 ;
  assign fragLenCnt$EN = 1'b0 ;

  // register hp
  assign hp$D_IN = hp_4_EQ_msgHeadLen_5___d73 ? 9'd0 : hp + 9'd1 ;
  assign hp$EN = CAN_FIRE_RL_sndHead ;

  // register lenR
  assign lenR$D_IN = 10'h0 ;
  assign lenR$EN = 1'b0 ;

  // register mhV
  assign mhV$D_IN = 33'd0 ;
  assign mhV$EN = CAN_FIRE_RL_popMhV ;

  // register mhV_1
  assign mhV_1$D_IN = 33'd1 ;
  assign mhV_1$EN = CAN_FIRE_RL_popMhV ;

  // register mhV_2
  assign mhV_2$D_IN = 33'd2 ;
  assign mhV_2$EN = CAN_FIRE_RL_popMhV ;

  // register mhV_3
  assign mhV_3$D_IN = 33'd3 ;
  assign mhV_3$EN = CAN_FIRE_RL_popMhV ;

  // register mhV_4
  assign mhV_4$D_IN = 33'd4 ;
  assign mhV_4$EN = CAN_FIRE_RL_popMhV ;

  // register mhV_5
  assign mhV_5$D_IN =
	     { (lengthF$D_OUT == 9'd0) ? 8'd128 : 8'd0,
	       lengthF$D_OUT,
	       16'b0 } ;
  assign mhV_5$EN = CAN_FIRE_RL_popMhV ;

  // register msgHeadLen
  assign msgHeadLen$D_IN = 9'h0 ;
  assign msgHeadLen$EN = 1'b0 ;

  // submodule headerF
  assign headerF$ENQ = lengthF$EMPTY_N && headerF$FULL_N ;
  assign headerF$DEQ = WILL_FIRE_RL_sndHead && hp_4_EQ_msgHeadLen_5___d73 ;
  assign headerF$CLR = 1'b0 ;

  // submodule lenToFHF
  assign lenToFHF$D_IN = 9'h0 ;
  assign lenToFHF$ENQ = 1'b0 ;
  assign lenToFHF$DEQ = EN_giveLen_get ;
  assign lenToFHF$CLR = 1'b0 ;

  // submodule lengthF
  assign lengthF$D_IN = newLen_put ;
  assign lengthF$ENQ = EN_newLen_put ;
  assign lengthF$DEQ = CAN_FIRE_RL_popMhV ;
  assign lengthF$CLR = 1'b0 ;

  // submodule mesgInF
  assign mesgInF$D_IN = sink_put ;
  assign mesgInF$ENQ = EN_sink_put ;
  assign mesgInF$DEQ = WILL_FIRE_RL_sndMesg ;
  assign mesgInF$CLR = 1'b0 ;

  // submodule mesgOutF
  assign mesgOutF$D_IN =
	     WILL_FIRE_RL_sndHead ?
	       MUX_mesgOutF$enq_1__VAL_1 :
	       mesgInF$D_OUT ;
  assign mesgOutF$ENQ = WILL_FIRE_RL_sndHead || WILL_FIRE_RL_sndMesg ;
  assign mesgOutF$DEQ = EN_src_get ;
  assign mesgOutF$CLR = 1'b0 ;

  // submodule messageF
  assign messageF$ENQ = WILL_FIRE_RL_sndHead && hp_4_EQ_msgHeadLen_5___d73 ;
  assign messageF$DEQ = WILL_FIRE_RL_sndMesg && mesgInF$D_OUT[32] ;
  assign messageF$CLR = 1'b0 ;

  // submodule msgDoneF
  assign msgDoneF$ENQ = 1'b0 ;
  assign msgDoneF$DEQ = 1'b0 ;
  assign msgDoneF$CLR = 1'b0 ;

  // remaining internal signals
  assign hp_4_EQ_msgHeadLen_5___d73 = hp == msgHeadLen ;
  assign mesgOutF_i_notFull__3_AND_NOT_hp_4_EQ_msgHeadL_ETC___d22 =
	     mesgOutF$FULL_N &&
	     (!hp_4_EQ_msgHeadLen_5___d73 ||
	      headerF$EMPTY_N && messageF$FULL_N) ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        eopR <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fragLenCnt <= `BSV_ASSIGNMENT_DELAY 9'd1;
	hp <= `BSV_ASSIGNMENT_DELAY 9'd0;
	lenR <= `BSV_ASSIGNMENT_DELAY 10'd170;
	msgHeadLen <= `BSV_ASSIGNMENT_DELAY 9'd5;
      end
    else
      begin
        if (eopR$EN) eopR <= `BSV_ASSIGNMENT_DELAY eopR$D_IN;
	if (fragLenCnt$EN)
	  fragLenCnt <= `BSV_ASSIGNMENT_DELAY fragLenCnt$D_IN;
	if (hp$EN) hp <= `BSV_ASSIGNMENT_DELAY hp$D_IN;
	if (lenR$EN) lenR <= `BSV_ASSIGNMENT_DELAY lenR$D_IN;
	if (msgHeadLen$EN)
	  msgHeadLen <= `BSV_ASSIGNMENT_DELAY msgHeadLen$D_IN;
      end
    if (mhV$EN) mhV <= `BSV_ASSIGNMENT_DELAY mhV$D_IN;
    if (mhV_1$EN) mhV_1 <= `BSV_ASSIGNMENT_DELAY mhV_1$D_IN;
    if (mhV_2$EN) mhV_2 <= `BSV_ASSIGNMENT_DELAY mhV_2$D_IN;
    if (mhV_3$EN) mhV_3 <= `BSV_ASSIGNMENT_DELAY mhV_3$D_IN;
    if (mhV_4$EN) mhV_4 <= `BSV_ASSIGNMENT_DELAY mhV_4$D_IN;
    if (mhV_5$EN) mhV_5 <= `BSV_ASSIGNMENT_DELAY mhV_5$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    eopR = 1'h0;
    fragLenCnt = 9'h0AA;
    hp = 9'h0AA;
    lenR = 10'h2AA;
    mhV = 33'h0AAAAAAAA;
    mhV_1 = 33'h0AAAAAAAA;
    mhV_2 = 33'h0AAAAAAAA;
    mhV_3 = 33'h0AAAAAAAA;
    mhV_4 = 33'h0AAAAAAAA;
    mhV_5 = 33'h0AAAAAAAA;
    msgHeadLen = 9'h0AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMHSender

