//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Tue Oct 16 11:19:23 EDT 2012
//
// Method conflict info:
// Method: src_get
// Conflicts: src_get
//
//
// Ports:
// Name                         I/O  size props
// src_get                        O    33 reg
// RDY_src_get                    O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// EN_src_get                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkGenerator(CLK,
		   RST_N,

		   EN_src_get,
		   src_get,
		   RDY_src_get);
  input  CLK;
  input  RST_N;

  // actionvalue method src_get
  input  EN_src_get;
  output [32 : 0] src_get;
  output RDY_src_get;

  // signals for module outputs
  wire [32 : 0] src_get;
  wire RDY_src_get;

  // register count
  reg [8 : 0] count;
  wire [8 : 0] count$D_IN;
  wire count$EN;

  // register initV
  reg [31 : 0] initV;
  wire [31 : 0] initV$D_IN;
  wire initV$EN;

  // register lfsr_r
  reg [31 : 0] lfsr_r;
  wire [31 : 0] lfsr_r$D_IN;
  wire lfsr_r$EN;

  // register maxLen
  reg [8 : 0] maxLen;
  wire [8 : 0] maxLen$D_IN;
  wire maxLen$EN;

  // register mesgLen
  reg [8 : 0] mesgLen;
  wire [8 : 0] mesgLen$D_IN;
  wire mesgLen$EN;

  // register minLen
  reg [8 : 0] minLen;
  wire [8 : 0] minLen$D_IN;
  wire minLen$EN;

  // register patternV
  reg [31 : 0] patternV;
  wire [31 : 0] patternV$D_IN;
  wire patternV$EN;

  // register seedLFSR
  reg seedLFSR;
  wire seedLFSR$D_IN, seedLFSR$EN;

  // register startLFSR
  reg startLFSR;
  wire startLFSR$D_IN, startLFSR$EN;

  // register tmp
  reg tmp;
  wire tmp$D_IN, tmp$EN;

  // ports of submodule mesgOutF
  wire [32 : 0] mesgOutF$D_IN, mesgOutF$D_OUT;
  wire mesgOutF$CLR,
       mesgOutF$DEQ,
       mesgOutF$EMPTY_N,
       mesgOutF$ENQ,
       mesgOutF$FULL_N;

  // ports of submodule randomF
  wire [8 : 0] randomF$D_IN, randomF$D_OUT;
  wire randomF$CLR, randomF$DEQ, randomF$EMPTY_N, randomF$ENQ, randomF$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_genMesgEOP,
       CAN_FIRE_RL_genMesgNotEOP,
       CAN_FIRE_RL_setMsgLen,
       CAN_FIRE_RL_setupLFSR,
       CAN_FIRE_src_get,
       WILL_FIRE_RL_genMesgEOP,
       WILL_FIRE_RL_genMesgNotEOP,
       WILL_FIRE_RL_setMsgLen,
       WILL_FIRE_RL_setupLFSR,
       WILL_FIRE_src_get;

  // inputs to muxes for submodule ports
  wire [32 : 0] MUX_mesgOutF$enq_1__VAL_1, MUX_mesgOutF$enq_1__VAL_2;
  wire [31 : 0] MUX_lfsr_r$write_1__VAL_2, MUX_patternV$write_1__VAL_2;
  wire [8 : 0] MUX_count$write_1__VAL_1;

  // remaining internal signals
  wire [8 : 0] mesgLen_8_MINUS_1___d73;
  wire lfsr_r_BITS_31_TO_23_ULE_6___d4, lfsr_r_BITS_31_TO_23_ULT_242___d5;

  // actionvalue method src_get
  assign src_get = mesgOutF$D_OUT ;
  assign RDY_src_get = mesgOutF$EMPTY_N ;
  assign CAN_FIRE_src_get = mesgOutF$EMPTY_N ;
  assign WILL_FIRE_src_get = EN_src_get ;

  // submodule mesgOutF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) mesgOutF(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(mesgOutF$D_IN),
						    .ENQ(mesgOutF$ENQ),
						    .DEQ(mesgOutF$DEQ),
						    .CLR(mesgOutF$CLR),
						    .D_OUT(mesgOutF$D_OUT),
						    .FULL_N(mesgOutF$FULL_N),
						    .EMPTY_N(mesgOutF$EMPTY_N));

  // submodule randomF
  FIFO2 #(.width(32'd9), .guarded(32'd1)) randomF(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(randomF$D_IN),
						  .ENQ(randomF$ENQ),
						  .DEQ(randomF$DEQ),
						  .CLR(randomF$CLR),
						  .D_OUT(randomF$D_OUT),
						  .FULL_N(randomF$FULL_N),
						  .EMPTY_N(randomF$EMPTY_N));

  // rule RL_setMsgLen
  assign CAN_FIRE_RL_setMsgLen =
	     (lfsr_r_BITS_31_TO_23_ULE_6___d4 ||
	      !lfsr_r_BITS_31_TO_23_ULT_242___d5 ||
	      randomF$FULL_N) &&
	     startLFSR ;
  assign WILL_FIRE_RL_setMsgLen = CAN_FIRE_RL_setMsgLen ;

  // rule RL_setupLFSR
  assign CAN_FIRE_RL_setupLFSR = seedLFSR ;
  assign WILL_FIRE_RL_setupLFSR = seedLFSR ;

  // rule RL_genMesgNotEOP
  assign CAN_FIRE_RL_genMesgNotEOP =
	     mesgOutF$FULL_N && count < mesgLen_8_MINUS_1___d73 ;
  assign WILL_FIRE_RL_genMesgNotEOP = CAN_FIRE_RL_genMesgNotEOP ;

  // rule RL_genMesgEOP
  assign CAN_FIRE_RL_genMesgEOP =
	     mesgOutF$FULL_N && randomF$EMPTY_N &&
	     count == mesgLen_8_MINUS_1___d73 ;
  assign WILL_FIRE_RL_genMesgEOP = CAN_FIRE_RL_genMesgEOP ;

  // inputs to muxes for submodule ports
  assign MUX_count$write_1__VAL_1 = count + 9'd1 ;
  assign MUX_lfsr_r$write_1__VAL_2 =
	     lfsr_r[0] ?
	       { 1'd1,
		 lfsr_r[31:8],
		 ~lfsr_r[7],
		 lfsr_r[6],
		 ~lfsr_r[5],
		 lfsr_r[4],
		 ~lfsr_r[3:1] } :
	       { 1'd0, lfsr_r[31:1] } ;
  assign MUX_mesgOutF$enq_1__VAL_1 = { 1'd0, patternV } ;
  assign MUX_mesgOutF$enq_1__VAL_2 = { 1'd1, patternV } ;
  assign MUX_patternV$write_1__VAL_2 =
	     { 8'd4 + patternV[31:24],
	       8'd4 + patternV[23:16],
	       8'd4 + patternV[15:8],
	       8'd4 + patternV[7:0] } ;

  // register count
  assign count$D_IN =
	     WILL_FIRE_RL_genMesgNotEOP ? MUX_count$write_1__VAL_1 : 9'd0 ;
  assign count$EN = WILL_FIRE_RL_genMesgNotEOP || WILL_FIRE_RL_genMesgEOP ;

  // register initV
  assign initV$D_IN =
	     { 8'd1 + initV[31:24],
	       8'd1 + initV[23:16],
	       8'd1 + initV[15:8],
	       8'd1 + initV[7:0] } ;
  assign initV$EN = CAN_FIRE_RL_genMesgEOP ;

  // register lfsr_r
  assign lfsr_r$D_IN = seedLFSR ? 32'h55555555 : MUX_lfsr_r$write_1__VAL_2 ;
  assign lfsr_r$EN = WILL_FIRE_RL_setMsgLen || seedLFSR ;

  // register maxLen
  assign maxLen$D_IN = (lfsr_r[31:23] <= maxLen) ? maxLen : lfsr_r[31:23] ;
  assign maxLen$EN =
	     WILL_FIRE_RL_setMsgLen && !lfsr_r_BITS_31_TO_23_ULE_6___d4 &&
	     lfsr_r_BITS_31_TO_23_ULT_242___d5 ;

  // register mesgLen
  assign mesgLen$D_IN = randomF$D_OUT ;
  assign mesgLen$EN = CAN_FIRE_RL_genMesgEOP ;

  // register minLen
  assign minLen$D_IN = (lfsr_r[31:23] < minLen) ? lfsr_r[31:23] : minLen ;
  assign minLen$EN =
	     WILL_FIRE_RL_setMsgLen && !lfsr_r_BITS_31_TO_23_ULE_6___d4 &&
	     lfsr_r_BITS_31_TO_23_ULT_242___d5 ;

  // register patternV
  assign patternV$D_IN =
	     WILL_FIRE_RL_genMesgEOP ? initV : MUX_patternV$write_1__VAL_2 ;
  assign patternV$EN = WILL_FIRE_RL_genMesgEOP || WILL_FIRE_RL_genMesgNotEOP ;

  // register seedLFSR
  assign seedLFSR$D_IN = 1'd0 ;
  assign seedLFSR$EN = seedLFSR ;

  // register startLFSR
  assign startLFSR$D_IN = 1'd1 ;
  assign startLFSR$EN = seedLFSR ;

  // register tmp
  assign tmp$D_IN = 1'b0 ;
  assign tmp$EN = 1'b0 ;

  // submodule mesgOutF
  assign mesgOutF$D_IN =
	     WILL_FIRE_RL_genMesgNotEOP ?
	       MUX_mesgOutF$enq_1__VAL_1 :
	       MUX_mesgOutF$enq_1__VAL_2 ;
  assign mesgOutF$ENQ =
	     WILL_FIRE_RL_genMesgNotEOP || WILL_FIRE_RL_genMesgEOP ;
  assign mesgOutF$DEQ = EN_src_get ;
  assign mesgOutF$CLR = 1'b0 ;

  // submodule randomF
  assign randomF$D_IN = lfsr_r[31:23] ;
  assign randomF$ENQ =
	     WILL_FIRE_RL_setMsgLen && !lfsr_r_BITS_31_TO_23_ULE_6___d4 &&
	     lfsr_r_BITS_31_TO_23_ULT_242___d5 ;
  assign randomF$DEQ = CAN_FIRE_RL_genMesgEOP ;
  assign randomF$CLR = 1'b0 ;

  // remaining internal signals
  assign lfsr_r_BITS_31_TO_23_ULE_6___d4 = lfsr_r[31:23] <= 9'd6 ;
  assign lfsr_r_BITS_31_TO_23_ULT_242___d5 = lfsr_r[31:23] < 9'd242 ;
  assign mesgLen_8_MINUS_1___d73 = mesgLen - 9'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        count <= `BSV_ASSIGNMENT_DELAY 9'd0;
	initV <= `BSV_ASSIGNMENT_DELAY 32'd16909060;
	lfsr_r <= `BSV_ASSIGNMENT_DELAY 32'd1;
	maxLen <= `BSV_ASSIGNMENT_DELAY 9'd0;
	mesgLen <= `BSV_ASSIGNMENT_DELAY 9'd10;
	minLen <= `BSV_ASSIGNMENT_DELAY 9'd511;
	patternV <= `BSV_ASSIGNMENT_DELAY 32'd66051;
	seedLFSR <= `BSV_ASSIGNMENT_DELAY 1'd1;
	startLFSR <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tmp <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (count$EN) count <= `BSV_ASSIGNMENT_DELAY count$D_IN;
	if (initV$EN) initV <= `BSV_ASSIGNMENT_DELAY initV$D_IN;
	if (lfsr_r$EN) lfsr_r <= `BSV_ASSIGNMENT_DELAY lfsr_r$D_IN;
	if (maxLen$EN) maxLen <= `BSV_ASSIGNMENT_DELAY maxLen$D_IN;
	if (mesgLen$EN) mesgLen <= `BSV_ASSIGNMENT_DELAY mesgLen$D_IN;
	if (minLen$EN) minLen <= `BSV_ASSIGNMENT_DELAY minLen$D_IN;
	if (patternV$EN) patternV <= `BSV_ASSIGNMENT_DELAY patternV$D_IN;
	if (seedLFSR$EN) seedLFSR <= `BSV_ASSIGNMENT_DELAY seedLFSR$D_IN;
	if (startLFSR$EN) startLFSR <= `BSV_ASSIGNMENT_DELAY startLFSR$D_IN;
	if (tmp$EN) tmp <= `BSV_ASSIGNMENT_DELAY tmp$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    count = 9'h0AA;
    initV = 32'hAAAAAAAA;
    lfsr_r = 32'hAAAAAAAA;
    maxLen = 9'h0AA;
    mesgLen = 9'h0AA;
    minLen = 9'h0AA;
    patternV = 32'hAAAAAAAA;
    seedLFSR = 1'h0;
    startLFSR = 1'h0;
    tmp = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkGenerator

