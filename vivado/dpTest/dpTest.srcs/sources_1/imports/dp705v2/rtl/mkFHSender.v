//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Fri Oct 19 11:51:31 EDT 2012
//
// Method conflict info:
// Method: ingress_put
// Conflict-free: egress_get
// Conflicts: ingress_put
//
// Method: egress_get
// Conflict-free: ingress_put
// Conflicts: egress_get
//
//
// Ports:
// Name                         I/O  size props
// RDY_ingress_put                O     1 reg
// egress_get                     O    33 reg
// RDY_egress_get                 O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ingress_put                    I    33 reg
// EN_ingress_put                 I     1
// EN_egress_get                  I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkFHSender(CLK,
		  RST_N,

		  ingress_put,
		  EN_ingress_put,
		  RDY_ingress_put,

		  EN_egress_get,
		  egress_get,
		  RDY_egress_get);
  input  CLK;
  input  RST_N;

  // action method ingress_put
  input  [32 : 0] ingress_put;
  input  EN_ingress_put;
  output RDY_ingress_put;

  // actionvalue method egress_get
  input  EN_egress_get;
  output [32 : 0] egress_get;
  output RDY_egress_get;

  // signals for module outputs
  wire [32 : 0] egress_get;
  wire RDY_egress_get, RDY_ingress_put;

  // register fhV
  reg [32 : 0] fhV;
  wire [32 : 0] fhV_D_IN;
  wire fhV_EN;

  // register fhV_1
  reg [32 : 0] fhV_1;
  wire [32 : 0] fhV_1_D_IN;
  wire fhV_1_EN;

  // register fhV_2
  reg [32 : 0] fhV_2;
  wire [32 : 0] fhV_2_D_IN;
  wire fhV_2_EN;

  // register fhp
  reg [3 : 0] fhp;
  wire [3 : 0] fhp_D_IN;
  wire fhp_EN;

  // register frmHeadLen
  reg [3 : 0] frmHeadLen;
  wire [3 : 0] frmHeadLen_D_IN;
  wire frmHeadLen_EN;

  // register sentFrmHead
  reg sentFrmHead;
  wire sentFrmHead_D_IN, sentFrmHead_EN;

  // register updateFH
  reg updateFH;
  wire updateFH_D_IN, updateFH_EN;

  // ports of submodule headerF
  wire headerF_CLR, headerF_DEQ, headerF_EMPTY_N, headerF_ENQ, headerF_FULL_N;

  // ports of submodule mesgInF
  wire [32 : 0] mesgInF_D_IN, mesgInF_D_OUT;
  wire mesgInF_CLR, mesgInF_DEQ, mesgInF_EMPTY_N, mesgInF_ENQ, mesgInF_FULL_N;

  // ports of submodule mesgOutF
  wire [32 : 0] mesgOutF_D_IN, mesgOutF_D_OUT;
  wire mesgOutF_CLR,
       mesgOutF_DEQ,
       mesgOutF_EMPTY_N,
       mesgOutF_ENQ,
       mesgOutF_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_popFhV,
       CAN_FIRE_RL_sndHead,
       CAN_FIRE_RL_sndMesg,
       CAN_FIRE_egress_get,
       CAN_FIRE_ingress_put,
       WILL_FIRE_RL_popFhV,
       WILL_FIRE_RL_sndHead,
       WILL_FIRE_RL_sndMesg,
       WILL_FIRE_egress_get,
       WILL_FIRE_ingress_put;

  // inputs to muxes for submodule ports
  reg [32 : 0] MUX_mesgOutF_enq_1__VAL_1;

  // remaining internal signals
  wire fhp_EQ_frmHeadLen___d49;

  // action method ingress_put
  assign RDY_ingress_put = mesgInF_FULL_N ;
  assign CAN_FIRE_ingress_put = mesgInF_FULL_N ;
  assign WILL_FIRE_ingress_put = EN_ingress_put ;

  // actionvalue method egress_get
  assign egress_get = mesgOutF_D_OUT ;
  assign RDY_egress_get = mesgOutF_EMPTY_N ;
  assign CAN_FIRE_egress_get = mesgOutF_EMPTY_N ;
  assign WILL_FIRE_egress_get = EN_egress_get ;

  // submodule headerF
  FIFO20 #(.guarded(32'd1)) headerF(.RST(RST_N),
				    .CLK(CLK),
				    .ENQ(headerF_ENQ),
				    .DEQ(headerF_DEQ),
				    .CLR(headerF_CLR),
				    .FULL_N(headerF_FULL_N),
				    .EMPTY_N(headerF_EMPTY_N));

  // submodule mesgInF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) mesgInF(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(mesgInF_D_IN),
						   .ENQ(mesgInF_ENQ),
						   .DEQ(mesgInF_DEQ),
						   .CLR(mesgInF_CLR),
						   .D_OUT(mesgInF_D_OUT),
						   .FULL_N(mesgInF_FULL_N),
						   .EMPTY_N(mesgInF_EMPTY_N));

  // submodule mesgOutF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) mesgOutF(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(mesgOutF_D_IN),
						    .ENQ(mesgOutF_ENQ),
						    .DEQ(mesgOutF_DEQ),
						    .CLR(mesgOutF_CLR),
						    .D_OUT(mesgOutF_D_OUT),
						    .FULL_N(mesgOutF_FULL_N),
						    .EMPTY_N(mesgOutF_EMPTY_N));

  // rule RL_popFhV
  assign CAN_FIRE_RL_popFhV = headerF_FULL_N && updateFH ;
  assign WILL_FIRE_RL_popFhV = CAN_FIRE_RL_popFhV ;

  // rule RL_sndHead
  assign CAN_FIRE_RL_sndHead =
	     mesgOutF_FULL_N && headerF_EMPTY_N && !sentFrmHead ;
  assign WILL_FIRE_RL_sndHead = CAN_FIRE_RL_sndHead && !WILL_FIRE_RL_popFhV ;

  // rule RL_sndMesg
  assign CAN_FIRE_RL_sndMesg =
	     mesgOutF_FULL_N && mesgInF_EMPTY_N && sentFrmHead ;
  assign WILL_FIRE_RL_sndMesg = CAN_FIRE_RL_sndMesg ;

  // inputs to muxes for submodule ports
  always@(fhp or fhV_2 or fhV or fhV_1)
  begin
    case (fhp)
      4'd1: MUX_mesgOutF_enq_1__VAL_1 = fhV;
      4'd2: MUX_mesgOutF_enq_1__VAL_1 = fhV_1;
      default: MUX_mesgOutF_enq_1__VAL_1 =
		   { fhp != 4'd3 || fhV_2[32], fhV_2[31:0] };
    endcase
  end

  // register fhV
  assign fhV_D_IN = 33'd10 ;
  assign fhV_EN = CAN_FIRE_RL_popFhV ;

  // register fhV_1
  assign fhV_1_D_IN = 33'd11 ;
  assign fhV_1_EN = CAN_FIRE_RL_popFhV ;

  // register fhV_2
  assign fhV_2_D_IN = 33'd12 ;
  assign fhV_2_EN = CAN_FIRE_RL_popFhV ;

  // register fhp
  assign fhp_D_IN = fhp_EQ_frmHeadLen___d49 ? 4'd1 : fhp + 4'd1 ;
  assign fhp_EN = WILL_FIRE_RL_sndHead ;

  // register frmHeadLen
  assign frmHeadLen_D_IN = 4'h0 ;
  assign frmHeadLen_EN = 1'b0 ;

  // register sentFrmHead
  assign sentFrmHead_D_IN =
	     WILL_FIRE_RL_sndMesg ?
	       !mesgInF_D_OUT[32] :
	       fhp_EQ_frmHeadLen___d49 ;
  assign sentFrmHead_EN = WILL_FIRE_RL_sndMesg || WILL_FIRE_RL_sndHead ;

  // register updateFH
  assign updateFH_D_IN = WILL_FIRE_RL_sndHead && fhp_EQ_frmHeadLen___d49 ;
  assign updateFH_EN = WILL_FIRE_RL_sndHead || WILL_FIRE_RL_popFhV ;

  // submodule headerF
  assign headerF_ENQ = CAN_FIRE_RL_popFhV ;
  assign headerF_DEQ = WILL_FIRE_RL_sndHead && fhp_EQ_frmHeadLen___d49 ;
  assign headerF_CLR = 1'b0 ;

  // submodule mesgInF
  assign mesgInF_D_IN = ingress_put ;
  assign mesgInF_ENQ = EN_ingress_put ;
  assign mesgInF_DEQ = CAN_FIRE_RL_sndMesg ;
  assign mesgInF_CLR = 1'b0 ;

  // submodule mesgOutF
  assign mesgOutF_D_IN =
	     WILL_FIRE_RL_sndHead ?
	       MUX_mesgOutF_enq_1__VAL_1 :
	       mesgInF_D_OUT ;
  assign mesgOutF_ENQ = WILL_FIRE_RL_sndHead || WILL_FIRE_RL_sndMesg ;
  assign mesgOutF_DEQ = EN_egress_get ;
  assign mesgOutF_CLR = 1'b0 ;

  // remaining internal signals
  assign fhp_EQ_frmHeadLen___d49 = fhp == frmHeadLen ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        fhp <= `BSV_ASSIGNMENT_DELAY 4'd1;
	frmHeadLen <= `BSV_ASSIGNMENT_DELAY 4'd3;
	sentFrmHead <= `BSV_ASSIGNMENT_DELAY 1'd0;
	updateFH <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (fhp_EN) fhp <= `BSV_ASSIGNMENT_DELAY fhp_D_IN;
	if (frmHeadLen_EN)
	  frmHeadLen <= `BSV_ASSIGNMENT_DELAY frmHeadLen_D_IN;
	if (sentFrmHead_EN)
	  sentFrmHead <= `BSV_ASSIGNMENT_DELAY sentFrmHead_D_IN;
	if (updateFH_EN) updateFH <= `BSV_ASSIGNMENT_DELAY updateFH_D_IN;
      end
    if (fhV_EN) fhV <= `BSV_ASSIGNMENT_DELAY fhV_D_IN;
    if (fhV_1_EN) fhV_1 <= `BSV_ASSIGNMENT_DELAY fhV_1_D_IN;
    if (fhV_2_EN) fhV_2 <= `BSV_ASSIGNMENT_DELAY fhV_2_D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    fhV = 33'h0AAAAAAAA;
    fhV_1 = 33'h0AAAAAAAA;
    fhV_2 = 33'h0AAAAAAAA;
    fhp = 4'hA;
    frmHeadLen = 4'hA;
    sentFrmHead = 1'h0;
    updateFH = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkFHSender

