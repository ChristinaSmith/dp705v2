//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Tue Oct 16 12:33:53 EDT 2012
//
// Method conflict info:
// Method: ledOutput
// Conflict-free: ledOutput
//
//
// Ports:
// Name                         I/O  size props
// ledOutput                      O     8 reg
// sys0_clk                       I     1 clock
// sys0_rstn                      I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkFTop_dp705(sys0_clk,
		    sys0_rstn,

		    ledOutput);
  input  sys0_clk;
  input  sys0_rstn;

  // value method ledOutput
  output [7 : 0] ledOutput;

  // signals for module outputs
  wire [7 : 0] ledOutput;

  // register cycleCounter
  reg [31 : 0] cycleCounter;
  wire [31 : 0] cycleCounter$D_IN;
  wire cycleCounter$EN;

  // register length
  reg [8 : 0] length;
  wire [8 : 0] length$D_IN;
  wire length$EN;

  // ports of submodule buf1
  wire [32 : 0] buf1$sink_put, buf1$src_get;
  wire [8 : 0] buf1$newLen_get;
  wire buf1$EN_length_dwm,
       buf1$EN_newLen_get,
       buf1$EN_sink_put,
       buf1$EN_src_get,
       buf1$RDY_length_dwm,
       buf1$RDY_newLen_get,
       buf1$RDY_sink_put,
       buf1$RDY_src_get;

  // ports of submodule chk
  wire [32 : 0] chk$sink1_put, chk$sink2_put;
  wire [3 : 0] chk$incorrectCnt;
  wire chk$EN_sink1_put,
       chk$EN_sink2_put,
       chk$RDY_sink1_put,
       chk$RDY_sink2_put;

  // ports of submodule fhrcv
  wire [32 : 0] fhrcv$egress_get, fhrcv$ingress_put;
  wire fhrcv$EN_egress_get,
       fhrcv$EN_ingress_put,
       fhrcv$RDY_egress_get,
       fhrcv$RDY_ingress_put;

  // ports of submodule fhsnd
  wire [32 : 0] fhsnd$egress_get, fhsnd$ingress_put;
  wire fhsnd$EN_egress_get,
       fhsnd$EN_ingress_put,
       fhsnd$RDY_egress_get,
       fhsnd$RDY_ingress_put;

  // ports of submodule gen1
  wire [32 : 0] gen1$src_get;
  wire gen1$EN_src_get, gen1$RDY_src_get;

  // ports of submodule gen2
  wire [32 : 0] gen2$src_get;
  wire gen2$EN_src_get, gen2$RDY_src_get;

  // ports of submodule mhrcv
  wire [32 : 0] mhrcv$egress_get, mhrcv$ingress_put;
  wire mhrcv$EN_egress_get,
       mhrcv$EN_ingress_put,
       mhrcv$RDY_egress_get,
       mhrcv$RDY_ingress_put;

  // ports of submodule mhsnd
  wire [32 : 0] mhsnd$sink_put, mhsnd$src_get;
  wire [8 : 0] mhsnd$newLen_put;
  wire mhsnd$EN_giveLen_get,
       mhsnd$EN_newLen_put,
       mhsnd$EN_sink_put,
       mhsnd$EN_src_get,
       mhsnd$RDY_newLen_put,
       mhsnd$RDY_sink_put,
       mhsnd$RDY_src_get,
       mhsnd$getLen_dwm;

  // ports of submodule rstndb
  wire rstndb$OUT_RST;

  // ports of submodule s2rF
  wire [32 : 0] s2rF$D_IN;
  wire s2rF$CLR, s2rF$DEQ, s2rF$ENQ;

  // rule scheduling signals
  wire CAN_FIRE_RL_cnctDwm,
       CAN_FIRE_RL_cycleCount,
       CAN_FIRE_RL_mkConnectionGetPut,
       CAN_FIRE_RL_mkConnectionGetPut_1,
       CAN_FIRE_RL_mkConnectionGetPut_2,
       CAN_FIRE_RL_mkConnectionGetPut_3,
       CAN_FIRE_RL_mkConnectionGetPut_4,
       CAN_FIRE_RL_mkConnectionGetPut_5,
       CAN_FIRE_RL_mkConnectionGetPut_6,
       CAN_FIRE_RL_mkConnectionGetPut_7,
       WILL_FIRE_RL_cnctDwm,
       WILL_FIRE_RL_cycleCount,
       WILL_FIRE_RL_mkConnectionGetPut,
       WILL_FIRE_RL_mkConnectionGetPut_1,
       WILL_FIRE_RL_mkConnectionGetPut_2,
       WILL_FIRE_RL_mkConnectionGetPut_3,
       WILL_FIRE_RL_mkConnectionGetPut_4,
       WILL_FIRE_RL_mkConnectionGetPut_5,
       WILL_FIRE_RL_mkConnectionGetPut_6,
       WILL_FIRE_RL_mkConnectionGetPut_7;

  // value method ledOutput
  assign ledOutput = { cycleCounter[31:28], chk$incorrectCnt } ;

  // submodule buf1
  mkBuffer buf1(.CLK(sys0_clk),
		.RST_N(rstndb$OUT_RST),
		.sink_put(buf1$sink_put),
		.EN_src_get(buf1$EN_src_get),
		.EN_sink_put(buf1$EN_sink_put),
		.EN_newLen_get(buf1$EN_newLen_get),
		.EN_length_dwm(buf1$EN_length_dwm),
		.src_get(buf1$src_get),
		.RDY_src_get(buf1$RDY_src_get),
		.RDY_sink_put(buf1$RDY_sink_put),
		.newLen_get(buf1$newLen_get),
		.RDY_newLen_get(buf1$RDY_newLen_get),
		.RDY_length_dwm(buf1$RDY_length_dwm));

  // submodule chk
  mkChecker chk(.CLK(sys0_clk),
		.RST_N(rstndb$OUT_RST),
		.sink1_put(chk$sink1_put),
		.sink2_put(chk$sink2_put),
		.EN_sink1_put(chk$EN_sink1_put),
		.EN_sink2_put(chk$EN_sink2_put),
		.RDY_sink1_put(chk$RDY_sink1_put),
		.RDY_sink2_put(chk$RDY_sink2_put),
		.incorrectCnt(chk$incorrectCnt),
		.RDY_incorrectCnt());

  // submodule fhrcv
  mkFHReceiver fhrcv(.CLK(sys0_clk),
		     .RST_N(rstndb$OUT_RST),
		     .ingress_put(fhrcv$ingress_put),
		     .EN_ingress_put(fhrcv$EN_ingress_put),
		     .EN_egress_get(fhrcv$EN_egress_get),
		     .RDY_ingress_put(fhrcv$RDY_ingress_put),
		     .egress_get(fhrcv$egress_get),
		     .RDY_egress_get(fhrcv$RDY_egress_get));

  // submodule fhsnd
  mkFHSender fhsnd(.CLK(sys0_clk),
		   .RST_N(rstndb$OUT_RST),
		   .ingress_put(fhsnd$ingress_put),
		   .EN_ingress_put(fhsnd$EN_ingress_put),
		   .EN_egress_get(fhsnd$EN_egress_get),
		   .RDY_ingress_put(fhsnd$RDY_ingress_put),
		   .egress_get(fhsnd$egress_get),
		   .RDY_egress_get(fhsnd$RDY_egress_get));

  // submodule gen1
  mkGenerator gen1(.CLK(sys0_clk),
		   .RST_N(rstndb$OUT_RST),
		   .EN_src_get(gen1$EN_src_get),
		   .src_get(gen1$src_get),
		   .RDY_src_get(gen1$RDY_src_get));

  // submodule gen2
  mkGenerator gen2(.CLK(sys0_clk),
		   .RST_N(rstndb$OUT_RST),
		   .EN_src_get(gen2$EN_src_get),
		   .src_get(gen2$src_get),
		   .RDY_src_get(gen2$RDY_src_get));

  // submodule mhrcv
  mkMHReceiver mhrcv(.CLK(sys0_clk),
		     .RST_N(rstndb$OUT_RST),
		     .ingress_put(mhrcv$ingress_put),
		     .EN_ingress_put(mhrcv$EN_ingress_put),
		     .EN_egress_get(mhrcv$EN_egress_get),
		     .RDY_ingress_put(mhrcv$RDY_ingress_put),
		     .egress_get(mhrcv$egress_get),
		     .RDY_egress_get(mhrcv$RDY_egress_get));

  // submodule mhsnd
  mkMHSender mhsnd(.CLK(sys0_clk),
		   .RST_N(rstndb$OUT_RST),
		   .newLen_put(mhsnd$newLen_put),
		   .sink_put(mhsnd$sink_put),
		   .EN_src_get(mhsnd$EN_src_get),
		   .EN_sink_put(mhsnd$EN_sink_put),
		   .EN_newLen_put(mhsnd$EN_newLen_put),
		   .EN_giveLen_get(mhsnd$EN_giveLen_get),
		   .src_get(mhsnd$src_get),
		   .RDY_src_get(mhsnd$RDY_src_get),
		   .RDY_sink_put(mhsnd$RDY_sink_put),
		   .RDY_newLen_put(mhsnd$RDY_newLen_put),
		   .getLen_dwm(mhsnd$getLen_dwm),
		   .RDY_getLen_dwm(),
		   .giveLen_get(),
		   .RDY_giveLen_get());

  // submodule rstndb
  SyncResetA #(.RSTDELAY(32'd15)) rstndb(.CLK(sys0_clk),
					 .IN_RST(sys0_rstn),
					 .OUT_RST(rstndb$OUT_RST));

  // submodule s2rF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) s2rF(.RST(rstndb$OUT_RST),
						.CLK(sys0_clk),
						.D_IN(s2rF$D_IN),
						.ENQ(s2rF$ENQ),
						.DEQ(s2rF$DEQ),
						.CLR(s2rF$CLR),
						.D_OUT(),
						.FULL_N(),
						.EMPTY_N());

  // rule RL_cycleCount
  assign CAN_FIRE_RL_cycleCount = 1'd1 ;
  assign WILL_FIRE_RL_cycleCount = 1'd1 ;

  // rule RL_mkConnectionGetPut
  assign CAN_FIRE_RL_mkConnectionGetPut =
	     gen1$RDY_src_get && buf1$RDY_sink_put ;
  assign WILL_FIRE_RL_mkConnectionGetPut = CAN_FIRE_RL_mkConnectionGetPut ;

  // rule RL_mkConnectionGetPut_1
  assign CAN_FIRE_RL_mkConnectionGetPut_1 =
	     buf1$RDY_newLen_get && mhsnd$RDY_newLen_put ;
  assign WILL_FIRE_RL_mkConnectionGetPut_1 =
	     CAN_FIRE_RL_mkConnectionGetPut_1 ;

  // rule RL_mkConnectionGetPut_2
  assign CAN_FIRE_RL_mkConnectionGetPut_2 =
	     buf1$RDY_src_get && mhsnd$RDY_sink_put ;
  assign WILL_FIRE_RL_mkConnectionGetPut_2 =
	     CAN_FIRE_RL_mkConnectionGetPut_2 ;

  // rule RL_cnctDwm
  assign CAN_FIRE_RL_cnctDwm = buf1$RDY_length_dwm && mhsnd$getLen_dwm ;
  assign WILL_FIRE_RL_cnctDwm = CAN_FIRE_RL_cnctDwm ;

  // rule RL_mkConnectionGetPut_3
  assign CAN_FIRE_RL_mkConnectionGetPut_3 =
	     mhsnd$RDY_src_get && fhsnd$RDY_ingress_put ;
  assign WILL_FIRE_RL_mkConnectionGetPut_3 =
	     CAN_FIRE_RL_mkConnectionGetPut_3 ;

  // rule RL_mkConnectionGetPut_4
  assign CAN_FIRE_RL_mkConnectionGetPut_4 =
	     fhrcv$RDY_ingress_put && fhsnd$RDY_egress_get ;
  assign WILL_FIRE_RL_mkConnectionGetPut_4 =
	     CAN_FIRE_RL_mkConnectionGetPut_4 ;

  // rule RL_mkConnectionGetPut_5
  assign CAN_FIRE_RL_mkConnectionGetPut_5 =
	     mhrcv$RDY_ingress_put && fhrcv$RDY_egress_get ;
  assign WILL_FIRE_RL_mkConnectionGetPut_5 =
	     CAN_FIRE_RL_mkConnectionGetPut_5 ;

  // rule RL_mkConnectionGetPut_6
  assign CAN_FIRE_RL_mkConnectionGetPut_6 =
	     chk$RDY_sink1_put && mhrcv$RDY_egress_get ;
  assign WILL_FIRE_RL_mkConnectionGetPut_6 =
	     CAN_FIRE_RL_mkConnectionGetPut_6 ;

  // rule RL_mkConnectionGetPut_7
  assign CAN_FIRE_RL_mkConnectionGetPut_7 =
	     gen2$RDY_src_get && chk$RDY_sink2_put ;
  assign WILL_FIRE_RL_mkConnectionGetPut_7 =
	     CAN_FIRE_RL_mkConnectionGetPut_7 ;

  // register cycleCounter
  assign cycleCounter$D_IN = cycleCounter + 32'd1 ;
  assign cycleCounter$EN = 1'd1 ;

  // register length
  assign length$D_IN = 9'h0 ;
  assign length$EN = 1'b0 ;

  // submodule buf1
  assign buf1$sink_put = gen1$src_get ;
  assign buf1$EN_src_get = CAN_FIRE_RL_mkConnectionGetPut_2 ;
  assign buf1$EN_sink_put = CAN_FIRE_RL_mkConnectionGetPut ;
  assign buf1$EN_newLen_get = CAN_FIRE_RL_mkConnectionGetPut_1 ;
  assign buf1$EN_length_dwm = CAN_FIRE_RL_cnctDwm ;

  // submodule chk
  assign chk$sink1_put = mhrcv$egress_get ;
  assign chk$sink2_put = gen2$src_get ;
  assign chk$EN_sink1_put = CAN_FIRE_RL_mkConnectionGetPut_6 ;
  assign chk$EN_sink2_put = CAN_FIRE_RL_mkConnectionGetPut_7 ;

  // submodule fhrcv
  assign fhrcv$ingress_put = fhsnd$egress_get ;
  assign fhrcv$EN_ingress_put = CAN_FIRE_RL_mkConnectionGetPut_4 ;
  assign fhrcv$EN_egress_get = CAN_FIRE_RL_mkConnectionGetPut_5 ;

  // submodule fhsnd
  assign fhsnd$ingress_put = mhsnd$src_get ;
  assign fhsnd$EN_ingress_put = CAN_FIRE_RL_mkConnectionGetPut_3 ;
  assign fhsnd$EN_egress_get = CAN_FIRE_RL_mkConnectionGetPut_4 ;

  // submodule gen1
  assign gen1$EN_src_get = CAN_FIRE_RL_mkConnectionGetPut ;

  // submodule gen2
  assign gen2$EN_src_get = CAN_FIRE_RL_mkConnectionGetPut_7 ;

  // submodule mhrcv
  assign mhrcv$ingress_put = fhrcv$egress_get ;
  assign mhrcv$EN_ingress_put = CAN_FIRE_RL_mkConnectionGetPut_5 ;
  assign mhrcv$EN_egress_get = CAN_FIRE_RL_mkConnectionGetPut_6 ;

  // submodule mhsnd
  assign mhsnd$newLen_put = buf1$newLen_get ;
  assign mhsnd$sink_put = buf1$src_get ;
  assign mhsnd$EN_src_get = CAN_FIRE_RL_mkConnectionGetPut_3 ;
  assign mhsnd$EN_sink_put = CAN_FIRE_RL_mkConnectionGetPut_2 ;
  assign mhsnd$EN_newLen_put = CAN_FIRE_RL_mkConnectionGetPut_1 ;
  assign mhsnd$EN_giveLen_get = 1'b0 ;

  // submodule s2rF
  assign s2rF$D_IN = 33'h0 ;
  assign s2rF$ENQ = 1'b0 ;
  assign s2rF$DEQ = 1'b0 ;
  assign s2rF$CLR = 1'b0 ;

  // handling of inlined registers

  always@(posedge sys0_clk)
  begin
    if (rstndb$OUT_RST == `BSV_RESET_VALUE)
      begin
        cycleCounter <= `BSV_ASSIGNMENT_DELAY 32'd0;
	length <= `BSV_ASSIGNMENT_DELAY 9'd0;
      end
    else
      begin
        if (cycleCounter$EN)
	  cycleCounter <= `BSV_ASSIGNMENT_DELAY cycleCounter$D_IN;
	if (length$EN) length <= `BSV_ASSIGNMENT_DELAY length$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cycleCounter = 32'hAAAAAAAA;
    length = 9'h0AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkFTop_dp705

