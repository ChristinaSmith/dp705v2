//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Tue Oct 16 11:19:22 EDT 2012
//
// Method conflict info:
// Method: sink1_put
// Conflict-free: sink2_put, incorrectCnt
// Conflicts: sink1_put
//
// Method: sink2_put
// Conflict-free: sink1_put, incorrectCnt
// Conflicts: sink2_put
//
// Method: incorrectCnt
// Conflict-free: sink1_put, sink2_put, incorrectCnt
//
//
// Ports:
// Name                         I/O  size props
// RDY_sink1_put                  O     1 reg
// RDY_sink2_put                  O     1 reg
// incorrectCnt                   O     4 reg
// RDY_incorrectCnt               O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// sink1_put                      I    33 reg
// sink2_put                      I    33 reg
// EN_sink1_put                   I     1
// EN_sink2_put                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkChecker(CLK,
		 RST_N,

		 sink1_put,
		 EN_sink1_put,
		 RDY_sink1_put,

		 sink2_put,
		 EN_sink2_put,
		 RDY_sink2_put,

		 incorrectCnt,
		 RDY_incorrectCnt);
  input  CLK;
  input  RST_N;

  // action method sink1_put
  input  [32 : 0] sink1_put;
  input  EN_sink1_put;
  output RDY_sink1_put;

  // action method sink2_put
  input  [32 : 0] sink2_put;
  input  EN_sink2_put;
  output RDY_sink2_put;

  // value method incorrectCnt
  output [3 : 0] incorrectCnt;
  output RDY_incorrectCnt;

  // signals for module outputs
  wire [3 : 0] incorrectCnt;
  wire RDY_incorrectCnt, RDY_sink1_put, RDY_sink2_put;

  // register buff
  reg [32 : 0] buff;
  wire [32 : 0] buff$D_IN;
  wire buff$EN;

  // register check
  reg [32 : 0] check;
  wire [32 : 0] check$D_IN;
  wire check$EN;

  // register cmpEOP
  reg cmpEOP;
  wire cmpEOP$D_IN, cmpEOP$EN;

  // register cmpFire
  reg cmpFire;
  wire cmpFire$D_IN, cmpFire$EN;

  // register cmpMatch
  reg cmpMatch;
  wire cmpMatch$D_IN, cmpMatch$EN;

  // register incorrect
  reg [7 : 0] incorrect;
  wire [7 : 0] incorrect$D_IN;
  wire incorrect$EN;

  // register maxLen
  reg [7 : 0] maxLen;
  wire [7 : 0] maxLen$D_IN;
  wire maxLen$EN;

  // register mesgCnt
  reg [7 : 0] mesgCnt;
  wire [7 : 0] mesgCnt$D_IN;
  wire mesgCnt$EN;

  // register minLen
  reg [7 : 0] minLen;
  wire [7 : 0] minLen$D_IN;
  wire minLen$EN;

  // register wordCnt
  reg [7 : 0] wordCnt;
  wire [7 : 0] wordCnt$D_IN;
  wire wordCnt$EN;

  // ports of submodule buffF
  wire [32 : 0] buffF$D_IN, buffF$D_OUT;
  wire buffF$CLR, buffF$DEQ, buffF$EMPTY_N, buffF$ENQ, buffF$FULL_N;

  // ports of submodule checkF
  wire [32 : 0] checkF$D_IN, checkF$D_OUT;
  wire checkF$CLR, checkF$DEQ, checkF$EMPTY_N, checkF$ENQ, checkF$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_cmpEOP__dreg_update,
       CAN_FIRE_RL_cmpFire__dreg_update,
       CAN_FIRE_RL_cmpMatch__dreg_update,
       CAN_FIRE_RL_compare,
       CAN_FIRE_sink1_put,
       CAN_FIRE_sink2_put,
       WILL_FIRE_RL_cmpEOP__dreg_update,
       WILL_FIRE_RL_cmpFire__dreg_update,
       WILL_FIRE_RL_cmpMatch__dreg_update,
       WILL_FIRE_RL_compare,
       WILL_FIRE_sink1_put,
       WILL_FIRE_sink2_put;

  // remaining internal signals
  wire [7 : 0] mesgCnt_4_REM_50___d35;
  wire checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45;

  // action method sink1_put
  assign RDY_sink1_put = buffF$FULL_N ;
  assign CAN_FIRE_sink1_put = buffF$FULL_N ;
  assign WILL_FIRE_sink1_put = EN_sink1_put ;

  // action method sink2_put
  assign RDY_sink2_put = checkF$FULL_N ;
  assign CAN_FIRE_sink2_put = checkF$FULL_N ;
  assign WILL_FIRE_sink2_put = EN_sink2_put ;

  // value method incorrectCnt
  assign incorrectCnt = incorrect[3:0] ;
  assign RDY_incorrectCnt = 1'd1 ;

  // submodule buffF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) buffF(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(buffF$D_IN),
						 .ENQ(buffF$ENQ),
						 .DEQ(buffF$DEQ),
						 .CLR(buffF$CLR),
						 .D_OUT(buffF$D_OUT),
						 .FULL_N(buffF$FULL_N),
						 .EMPTY_N(buffF$EMPTY_N));

  // submodule checkF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) checkF(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(checkF$D_IN),
						  .ENQ(checkF$ENQ),
						  .DEQ(checkF$DEQ),
						  .CLR(checkF$CLR),
						  .D_OUT(checkF$D_OUT),
						  .FULL_N(checkF$FULL_N),
						  .EMPTY_N(checkF$EMPTY_N));

  // rule RL_compare
  assign CAN_FIRE_RL_compare = buffF$EMPTY_N && checkF$EMPTY_N ;
  assign WILL_FIRE_RL_compare = CAN_FIRE_RL_compare ;

  // rule RL_cmpFire__dreg_update
  assign CAN_FIRE_RL_cmpFire__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_cmpFire__dreg_update = 1'd1 ;

  // rule RL_cmpEOP__dreg_update
  assign CAN_FIRE_RL_cmpEOP__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_cmpEOP__dreg_update = 1'd1 ;

  // rule RL_cmpMatch__dreg_update
  assign CAN_FIRE_RL_cmpMatch__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_cmpMatch__dreg_update = 1'd1 ;

  // register buff
  assign buff$D_IN = buffF$D_OUT ;
  assign buff$EN = CAN_FIRE_RL_compare ;

  // register check
  assign check$D_IN = checkF$D_OUT ;
  assign check$EN = CAN_FIRE_RL_compare ;

  // register cmpEOP
  assign cmpEOP$D_IN = CAN_FIRE_RL_compare && checkF$D_OUT[32] ;
  assign cmpEOP$EN = 1'd1 ;

  // register cmpFire
  assign cmpFire$D_IN = CAN_FIRE_RL_compare ;
  assign cmpFire$EN = 1'd1 ;

  // register cmpMatch
  assign cmpMatch$D_IN =
	     CAN_FIRE_RL_compare &&
	     checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45 ;
  assign cmpMatch$EN = 1'd1 ;

  // register incorrect
  assign incorrect$D_IN = incorrect + 8'd1 ;
  assign incorrect$EN =
	     WILL_FIRE_RL_compare &&
	     !checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45 ;

  // register maxLen
  assign maxLen$D_IN = (wordCnt <= maxLen) ? maxLen : wordCnt ;
  assign maxLen$EN =
	     WILL_FIRE_RL_compare &&
	     checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45 &&
	     checkF$D_OUT[32] ;

  // register mesgCnt
  assign mesgCnt$D_IN = mesgCnt + 8'd1 ;
  assign mesgCnt$EN =
	     WILL_FIRE_RL_compare &&
	     checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45 &&
	     checkF$D_OUT[32] ;

  // register minLen
  assign minLen$D_IN = (wordCnt < minLen) ? wordCnt : minLen ;
  assign minLen$EN =
	     WILL_FIRE_RL_compare &&
	     checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45 &&
	     checkF$D_OUT[32] ;

  // register wordCnt
  assign wordCnt$D_IN =
	     (checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45 &&
	      checkF$D_OUT[32]) ?
	       8'd1 :
	       (checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45 ?
		  wordCnt + 8'd1 :
		  wordCnt) ;
  assign wordCnt$EN = CAN_FIRE_RL_compare ;

  // submodule buffF
  assign buffF$D_IN = sink1_put ;
  assign buffF$ENQ = EN_sink1_put ;
  assign buffF$DEQ = CAN_FIRE_RL_compare ;
  assign buffF$CLR = 1'b0 ;

  // submodule checkF
  assign checkF$D_IN = sink2_put ;
  assign checkF$ENQ = EN_sink2_put ;
  assign checkF$DEQ = CAN_FIRE_RL_compare ;
  assign checkF$CLR = 1'b0 ;

  // remaining internal signals
  assign checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45 =
	     checkF$D_OUT[31:0] == buffF$D_OUT[31:0] ;
  assign mesgCnt_4_REM_50___d35 = mesgCnt % 8'd50 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        buff <= `BSV_ASSIGNMENT_DELAY 33'h0AAAAAAAA;
	check <= `BSV_ASSIGNMENT_DELAY 33'h0AAAAAAAA;
	cmpEOP <= `BSV_ASSIGNMENT_DELAY 1'd0;
	cmpFire <= `BSV_ASSIGNMENT_DELAY 1'd0;
	cmpMatch <= `BSV_ASSIGNMENT_DELAY 1'd0;
	incorrect <= `BSV_ASSIGNMENT_DELAY 8'd0;
	maxLen <= `BSV_ASSIGNMENT_DELAY 8'd0;
	mesgCnt <= `BSV_ASSIGNMENT_DELAY 8'd1;
	minLen <= `BSV_ASSIGNMENT_DELAY 8'd255;
	wordCnt <= `BSV_ASSIGNMENT_DELAY 8'd1;
      end
    else
      begin
        if (buff$EN) buff <= `BSV_ASSIGNMENT_DELAY buff$D_IN;
	if (check$EN) check <= `BSV_ASSIGNMENT_DELAY check$D_IN;
	if (cmpEOP$EN) cmpEOP <= `BSV_ASSIGNMENT_DELAY cmpEOP$D_IN;
	if (cmpFire$EN) cmpFire <= `BSV_ASSIGNMENT_DELAY cmpFire$D_IN;
	if (cmpMatch$EN) cmpMatch <= `BSV_ASSIGNMENT_DELAY cmpMatch$D_IN;
	if (incorrect$EN) incorrect <= `BSV_ASSIGNMENT_DELAY incorrect$D_IN;
	if (maxLen$EN) maxLen <= `BSV_ASSIGNMENT_DELAY maxLen$D_IN;
	if (mesgCnt$EN) mesgCnt <= `BSV_ASSIGNMENT_DELAY mesgCnt$D_IN;
	if (minLen$EN) minLen <= `BSV_ASSIGNMENT_DELAY minLen$D_IN;
	if (wordCnt$EN) wordCnt <= `BSV_ASSIGNMENT_DELAY wordCnt$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    buff = 33'h0AAAAAAAA;
    check = 33'h0AAAAAAAA;
    cmpEOP = 1'h0;
    cmpFire = 1'h0;
    cmpMatch = 1'h0;
    incorrect = 8'hAA;
    maxLen = 8'hAA;
    mesgCnt = 8'hAA;
    minLen = 8'hAA;
    wordCnt = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_compare &&
	  checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45 &&
	  checkF$D_OUT[32])
	$display("Message Count: %d || Length: %d || Last word rcv'd: %0x",
		 mesgCnt,
		 wordCnt,
		 buffF$D_OUT[31:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_compare &&
	  (!checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45 ||
	   !checkF$D_OUT[32]) &&
	  mesgCnt_4_REM_50___d35 == 8'd1)
	$display("Max Length: %d, Min Length: %d", maxLen, minLen);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_compare &&
	  !checkF_first__4_BITS_31_TO_0_5_EQ_buffF_first__ETC___d45)
	$display("Message Error: %0x, %0x",
		 buffF$D_OUT[31:0],
		 checkF$D_OUT[31:0]);
  end
  // synopsys translate_on
endmodule  // mkChecker

