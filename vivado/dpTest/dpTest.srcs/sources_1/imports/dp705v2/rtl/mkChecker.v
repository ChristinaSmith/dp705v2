//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Fri Oct 19 11:51:31 EDT 2012
//
// Method conflict info:
// Method: sink1_put
// Conflict-free: sink2_put, incorrectCnt
// Conflicts: sink1_put
//
// Method: sink2_put
// Conflict-free: sink1_put, incorrectCnt
// Conflicts: sink2_put
//
// Method: incorrectCnt
// Conflict-free: sink1_put, sink2_put, incorrectCnt
//
//
// Ports:
// Name                         I/O  size props
// RDY_sink1_put                  O     1 reg
// RDY_sink2_put                  O     1 reg
// incorrectCnt                   O     4 reg
// RDY_incorrectCnt               O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// sink1_put                      I    33 reg
// sink2_put                      I    33 reg
// EN_sink1_put                   I     1
// EN_sink2_put                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkChecker(CLK,
		 RST_N,

		 sink1_put,
		 EN_sink1_put,
		 RDY_sink1_put,

		 sink2_put,
		 EN_sink2_put,
		 RDY_sink2_put,

		 incorrectCnt,
		 RDY_incorrectCnt);
  input  CLK;
  input  RST_N;

  // action method sink1_put
  input  [32 : 0] sink1_put;
  input  EN_sink1_put;
  output RDY_sink1_put;

  // action method sink2_put
  input  [32 : 0] sink2_put;
  input  EN_sink2_put;
  output RDY_sink2_put;

  // value method incorrectCnt
  output [3 : 0] incorrectCnt;
  output RDY_incorrectCnt;

  // signals for module outputs
  wire [3 : 0] incorrectCnt;
  wire RDY_incorrectCnt, RDY_sink1_put, RDY_sink2_put;

  // register cmpEOP
  reg cmpEOP;
  wire cmpEOP_D_IN, cmpEOP_EN;

  // register cmpFire
  reg cmpFire;
  wire cmpFire_D_IN, cmpFire_EN;

  // register cmpMatch
  reg cmpMatch;
  wire cmpMatch_D_IN, cmpMatch_EN;

  // register incorrect
  reg [7 : 0] incorrect;
  wire [7 : 0] incorrect_D_IN;
  wire incorrect_EN;

  // register maxLen
  reg [7 : 0] maxLen;
  wire [7 : 0] maxLen_D_IN;
  wire maxLen_EN;

  // register mesgCnt
  reg [7 : 0] mesgCnt;
  wire [7 : 0] mesgCnt_D_IN;
  wire mesgCnt_EN;

  // register minLen
  reg [7 : 0] minLen;
  wire [7 : 0] minLen_D_IN;
  wire minLen_EN;

  // register wordCnt
  reg [7 : 0] wordCnt;
  wire [7 : 0] wordCnt_D_IN;
  wire wordCnt_EN;

  // ports of submodule buffF
  wire [32 : 0] buffF_D_IN, buffF_D_OUT;
  wire buffF_CLR, buffF_DEQ, buffF_EMPTY_N, buffF_ENQ, buffF_FULL_N;

  // ports of submodule checkF
  wire [32 : 0] checkF_D_IN, checkF_D_OUT;
  wire checkF_CLR, checkF_DEQ, checkF_EMPTY_N, checkF_ENQ, checkF_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_cmpEOP__dreg_update,
       CAN_FIRE_RL_cmpFire__dreg_update,
       CAN_FIRE_RL_cmpMatch__dreg_update,
       CAN_FIRE_RL_compare,
       CAN_FIRE_sink1_put,
       CAN_FIRE_sink2_put,
       WILL_FIRE_RL_cmpEOP__dreg_update,
       WILL_FIRE_RL_cmpFire__dreg_update,
       WILL_FIRE_RL_cmpMatch__dreg_update,
       WILL_FIRE_RL_compare,
       WILL_FIRE_sink1_put,
       WILL_FIRE_sink2_put;

  // remaining internal signals
  wire checkF_first__3_BITS_31_TO_0_4_EQ_buffF_first__ETC___d37;

  // action method sink1_put
  assign RDY_sink1_put = buffF_FULL_N ;
  assign CAN_FIRE_sink1_put = buffF_FULL_N ;
  assign WILL_FIRE_sink1_put = EN_sink1_put ;

  // action method sink2_put
  assign RDY_sink2_put = checkF_FULL_N ;
  assign CAN_FIRE_sink2_put = checkF_FULL_N ;
  assign WILL_FIRE_sink2_put = EN_sink2_put ;

  // value method incorrectCnt
  assign incorrectCnt = incorrect[3:0] ;
  assign RDY_incorrectCnt = 1'd1 ;

  // submodule buffF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) buffF(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(buffF_D_IN),
						 .ENQ(buffF_ENQ),
						 .DEQ(buffF_DEQ),
						 .CLR(buffF_CLR),
						 .D_OUT(buffF_D_OUT),
						 .FULL_N(buffF_FULL_N),
						 .EMPTY_N(buffF_EMPTY_N));

  // submodule checkF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) checkF(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(checkF_D_IN),
						  .ENQ(checkF_ENQ),
						  .DEQ(checkF_DEQ),
						  .CLR(checkF_CLR),
						  .D_OUT(checkF_D_OUT),
						  .FULL_N(checkF_FULL_N),
						  .EMPTY_N(checkF_EMPTY_N));

  // rule RL_compare
  assign CAN_FIRE_RL_compare = buffF_EMPTY_N && checkF_EMPTY_N ;
  assign WILL_FIRE_RL_compare = CAN_FIRE_RL_compare ;

  // rule RL_cmpFire__dreg_update
  assign CAN_FIRE_RL_cmpFire__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_cmpFire__dreg_update = 1'd1 ;

  // rule RL_cmpEOP__dreg_update
  assign CAN_FIRE_RL_cmpEOP__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_cmpEOP__dreg_update = 1'd1 ;

  // rule RL_cmpMatch__dreg_update
  assign CAN_FIRE_RL_cmpMatch__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_cmpMatch__dreg_update = 1'd1 ;

  // register cmpEOP
  assign cmpEOP_D_IN = CAN_FIRE_RL_compare && checkF_D_OUT[32] ;
  assign cmpEOP_EN = 1'd1 ;

  // register cmpFire
  assign cmpFire_D_IN = CAN_FIRE_RL_compare ;
  assign cmpFire_EN = 1'd1 ;

  // register cmpMatch
  assign cmpMatch_D_IN =
	     CAN_FIRE_RL_compare &&
	     checkF_first__3_BITS_31_TO_0_4_EQ_buffF_first__ETC___d37 ;
  assign cmpMatch_EN = 1'd1 ;

  // register incorrect
  assign incorrect_D_IN = incorrect + 8'd1 ;
  assign incorrect_EN =
	     WILL_FIRE_RL_compare &&
	     !checkF_first__3_BITS_31_TO_0_4_EQ_buffF_first__ETC___d37 ;

  // register maxLen
  assign maxLen_D_IN = (wordCnt <= maxLen) ? maxLen : wordCnt ;
  assign maxLen_EN =
	     WILL_FIRE_RL_compare &&
	     checkF_first__3_BITS_31_TO_0_4_EQ_buffF_first__ETC___d37 &&
	     checkF_D_OUT[32] ;

  // register mesgCnt
  assign mesgCnt_D_IN = mesgCnt + 8'd1 ;
  assign mesgCnt_EN =
	     WILL_FIRE_RL_compare &&
	     checkF_first__3_BITS_31_TO_0_4_EQ_buffF_first__ETC___d37 &&
	     checkF_D_OUT[32] ;

  // register minLen
  assign minLen_D_IN = (wordCnt < minLen) ? wordCnt : minLen ;
  assign minLen_EN =
	     WILL_FIRE_RL_compare &&
	     checkF_first__3_BITS_31_TO_0_4_EQ_buffF_first__ETC___d37 &&
	     checkF_D_OUT[32] ;

  // register wordCnt
  assign wordCnt_D_IN =
	     (checkF_first__3_BITS_31_TO_0_4_EQ_buffF_first__ETC___d37 &&
	      checkF_D_OUT[32]) ?
	       8'd1 :
	       (checkF_first__3_BITS_31_TO_0_4_EQ_buffF_first__ETC___d37 ?
		  wordCnt + 8'd1 :
		  wordCnt) ;
  assign wordCnt_EN = CAN_FIRE_RL_compare ;

  // submodule buffF
  assign buffF_D_IN = sink1_put ;
  assign buffF_ENQ = EN_sink1_put ;
  assign buffF_DEQ = CAN_FIRE_RL_compare ;
  assign buffF_CLR = 1'b0 ;

  // submodule checkF
  assign checkF_D_IN = sink2_put ;
  assign checkF_ENQ = EN_sink2_put ;
  assign checkF_DEQ = CAN_FIRE_RL_compare ;
  assign checkF_CLR = 1'b0 ;

  // remaining internal signals
  assign checkF_first__3_BITS_31_TO_0_4_EQ_buffF_first__ETC___d37 =
	     checkF_D_OUT[31:0] == buffF_D_OUT[31:0] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cmpEOP <= `BSV_ASSIGNMENT_DELAY 1'd0;
	cmpFire <= `BSV_ASSIGNMENT_DELAY 1'd0;
	cmpMatch <= `BSV_ASSIGNMENT_DELAY 1'd0;
	incorrect <= `BSV_ASSIGNMENT_DELAY 8'd0;
	maxLen <= `BSV_ASSIGNMENT_DELAY 8'd0;
	mesgCnt <= `BSV_ASSIGNMENT_DELAY 8'd1;
	minLen <= `BSV_ASSIGNMENT_DELAY 8'd255;
	wordCnt <= `BSV_ASSIGNMENT_DELAY 8'd1;
      end
    else
      begin
        if (cmpEOP_EN) cmpEOP <= `BSV_ASSIGNMENT_DELAY cmpEOP_D_IN;
	if (cmpFire_EN) cmpFire <= `BSV_ASSIGNMENT_DELAY cmpFire_D_IN;
	if (cmpMatch_EN) cmpMatch <= `BSV_ASSIGNMENT_DELAY cmpMatch_D_IN;
	if (incorrect_EN) incorrect <= `BSV_ASSIGNMENT_DELAY incorrect_D_IN;
	if (maxLen_EN) maxLen <= `BSV_ASSIGNMENT_DELAY maxLen_D_IN;
	if (mesgCnt_EN) mesgCnt <= `BSV_ASSIGNMENT_DELAY mesgCnt_D_IN;
	if (minLen_EN) minLen <= `BSV_ASSIGNMENT_DELAY minLen_D_IN;
	if (wordCnt_EN) wordCnt <= `BSV_ASSIGNMENT_DELAY wordCnt_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cmpEOP = 1'h0;
    cmpFire = 1'h0;
    cmpMatch = 1'h0;
    incorrect = 8'hAA;
    maxLen = 8'hAA;
    mesgCnt = 8'hAA;
    minLen = 8'hAA;
    wordCnt = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_compare &&
	  !checkF_first__3_BITS_31_TO_0_4_EQ_buffF_first__ETC___d37)
	$display("Message Error: %0x, %0x",
		 buffF_D_OUT[31:0],
		 checkF_D_OUT[31:0]);
  end
  // synopsys translate_on
endmodule  // mkChecker

