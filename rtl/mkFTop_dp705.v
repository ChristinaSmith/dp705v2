//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Fri Oct 19 15:35:26 EDT 2012
//
// Method conflict info:
// Method: ledOutput
// Conflict-free: ledOutput
//
//
// Ports:
// Name                         I/O  size props
// ledOutput                      O     8 reg
// sys0_clk                       I     1 clock
// sys0_rstn                      I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkFTop_dp705(sys0_clk,
		    sys0_rstn,

		    ledOutput);
  input  sys0_clk;
  input  sys0_rstn;

  // value method ledOutput
  output [7 : 0] ledOutput;

  // signals for module outputs
  wire [7 : 0] ledOutput;

  // register cycleCounter
  reg [31 : 0] cycleCounter;
  wire [31 : 0] cycleCounter_D_IN;
  wire cycleCounter_EN;

  // register length
  reg [8 : 0] length;
  wire [8 : 0] length_D_IN;
  wire length_EN;

  // ports of submodule buf1
  wire [32 : 0] buf1_sink_put, buf1_src_get;
  wire [8 : 0] buf1_newLen_get;
  wire buf1_EN_length_dwm,
       buf1_EN_newLen_get,
       buf1_EN_sink_put,
       buf1_EN_src_get,
       buf1_RDY_length_dwm,
       buf1_RDY_newLen_get,
       buf1_RDY_sink_put,
       buf1_RDY_src_get;

  // ports of submodule chk
  wire [32 : 0] chk_sink1_put, chk_sink2_put;
  wire [3 : 0] chk_incorrectCnt;
  wire chk_EN_sink1_put,
       chk_EN_sink2_put,
       chk_RDY_sink1_put,
       chk_RDY_sink2_put;

  // ports of submodule fhrcv
  wire [32 : 0] fhrcv_egress_get, fhrcv_ingress_put;
  wire fhrcv_EN_egress_get,
       fhrcv_EN_ingress_put,
       fhrcv_RDY_egress_get,
       fhrcv_RDY_ingress_put;

  // ports of submodule fhsnd
  wire [32 : 0] fhsnd_egress_get, fhsnd_ingress_put;
  wire fhsnd_EN_egress_get,
       fhsnd_EN_ingress_put,
       fhsnd_RDY_egress_get,
       fhsnd_RDY_ingress_put;

  // ports of submodule gen1
  wire [32 : 0] gen1_src_get;
  wire gen1_EN_src_get, gen1_RDY_src_get;

  // ports of submodule gen2
  wire [32 : 0] gen2_src_get;
  wire gen2_EN_src_get, gen2_RDY_src_get;

  // ports of submodule mhrcv
  wire [32 : 0] mhrcv_egress_get, mhrcv_ingress_put;
  wire mhrcv_EN_egress_get,
       mhrcv_EN_ingress_put,
       mhrcv_RDY_egress_get,
       mhrcv_RDY_ingress_put;

  // ports of submodule mhsnd
  wire [32 : 0] mhsnd_sink_put, mhsnd_src_get;
  wire [8 : 0] mhsnd_newLen_put;
  wire mhsnd_EN_giveLen_get,
       mhsnd_EN_newLen_put,
       mhsnd_EN_sink_put,
       mhsnd_EN_src_get,
       mhsnd_RDY_newLen_put,
       mhsnd_RDY_sink_put,
       mhsnd_RDY_src_get,
       mhsnd_getLen_dwm;

  // ports of submodule rstndb
  wire rstndb_OUT_RST;

  // ports of submodule s2rF
  wire [32 : 0] s2rF_D_IN;
  wire s2rF_CLR, s2rF_DEQ, s2rF_ENQ;

  // rule scheduling signals
  wire CAN_FIRE_RL_cnctDwm,
       CAN_FIRE_RL_cycleCount,
       CAN_FIRE_RL_gobble,
       CAN_FIRE_RL_mkConnectionGetPut,
       CAN_FIRE_RL_mkConnectionGetPut_1,
       CAN_FIRE_RL_mkConnectionGetPut_2,
       CAN_FIRE_RL_mkConnectionGetPut_3,
       CAN_FIRE_RL_mkConnectionGetPut_4,
       CAN_FIRE_RL_mkConnectionGetPut_5,
       CAN_FIRE_RL_mkConnectionGetPut_6,
       CAN_FIRE_RL_mkConnectionGetPut_7,
       WILL_FIRE_RL_cnctDwm,
       WILL_FIRE_RL_cycleCount,
       WILL_FIRE_RL_gobble,
       WILL_FIRE_RL_mkConnectionGetPut,
       WILL_FIRE_RL_mkConnectionGetPut_1,
       WILL_FIRE_RL_mkConnectionGetPut_2,
       WILL_FIRE_RL_mkConnectionGetPut_3,
       WILL_FIRE_RL_mkConnectionGetPut_4,
       WILL_FIRE_RL_mkConnectionGetPut_5,
       WILL_FIRE_RL_mkConnectionGetPut_6,
       WILL_FIRE_RL_mkConnectionGetPut_7;

  // value method ledOutput
  assign ledOutput = { cycleCounter[31:28], chk_incorrectCnt } ;

  // submodule buf1
  mkBuffer buf1(.CLK(sys0_clk),
		.RST_N(rstndb_OUT_RST),
		.sink_put(buf1_sink_put),
		.EN_src_get(buf1_EN_src_get),
		.EN_sink_put(buf1_EN_sink_put),
		.EN_newLen_get(buf1_EN_newLen_get),
		.EN_length_dwm(buf1_EN_length_dwm),
		.src_get(buf1_src_get),
		.RDY_src_get(buf1_RDY_src_get),
		.RDY_sink_put(buf1_RDY_sink_put),
		.newLen_get(buf1_newLen_get),
		.RDY_newLen_get(buf1_RDY_newLen_get),
		.RDY_length_dwm(buf1_RDY_length_dwm));

  // submodule chk
  mkChecker chk(.CLK(sys0_clk),
		.RST_N(rstndb_OUT_RST),
		.sink1_put(chk_sink1_put),
		.sink2_put(chk_sink2_put),
		.EN_sink1_put(chk_EN_sink1_put),
		.EN_sink2_put(chk_EN_sink2_put),
		.RDY_sink1_put(chk_RDY_sink1_put),
		.RDY_sink2_put(chk_RDY_sink2_put),
		.incorrectCnt(chk_incorrectCnt),
		.RDY_incorrectCnt());

  // submodule fhrcv
  mkFHReceiver fhrcv(.CLK(sys0_clk),
		     .RST_N(rstndb_OUT_RST),
		     .ingress_put(fhrcv_ingress_put),
		     .EN_ingress_put(fhrcv_EN_ingress_put),
		     .EN_egress_get(fhrcv_EN_egress_get),
		     .RDY_ingress_put(fhrcv_RDY_ingress_put),
		     .egress_get(fhrcv_egress_get),
		     .RDY_egress_get(fhrcv_RDY_egress_get));

  // submodule fhsnd
  mkFHSender fhsnd(.CLK(sys0_clk),
		   .RST_N(rstndb_OUT_RST),
		   .ingress_put(fhsnd_ingress_put),
		   .EN_ingress_put(fhsnd_EN_ingress_put),
		   .EN_egress_get(fhsnd_EN_egress_get),
		   .RDY_ingress_put(fhsnd_RDY_ingress_put),
		   .egress_get(fhsnd_egress_get),
		   .RDY_egress_get(fhsnd_RDY_egress_get));

  // submodule gen1
  mkGenerator gen1(.CLK(sys0_clk),
		   .RST_N(rstndb_OUT_RST),
		   .EN_src_get(gen1_EN_src_get),
		   .src_get(gen1_src_get),
		   .RDY_src_get(gen1_RDY_src_get));

  // submodule gen2
  mkGenerator gen2(.CLK(sys0_clk),
		   .RST_N(rstndb_OUT_RST),
		   .EN_src_get(gen2_EN_src_get),
		   .src_get(gen2_src_get),
		   .RDY_src_get(gen2_RDY_src_get));

  // submodule mhrcv
  mkMHReceiver mhrcv(.CLK(sys0_clk),
		     .RST_N(rstndb_OUT_RST),
		     .ingress_put(mhrcv_ingress_put),
		     .EN_ingress_put(mhrcv_EN_ingress_put),
		     .EN_egress_get(mhrcv_EN_egress_get),
		     .RDY_ingress_put(mhrcv_RDY_ingress_put),
		     .egress_get(mhrcv_egress_get),
		     .RDY_egress_get(mhrcv_RDY_egress_get));

  // submodule mhsnd
  mkMHSender mhsnd(.CLK(sys0_clk),
		   .RST_N(rstndb_OUT_RST),
		   .newLen_put(mhsnd_newLen_put),
		   .sink_put(mhsnd_sink_put),
		   .EN_src_get(mhsnd_EN_src_get),
		   .EN_sink_put(mhsnd_EN_sink_put),
		   .EN_newLen_put(mhsnd_EN_newLen_put),
		   .EN_giveLen_get(mhsnd_EN_giveLen_get),
		   .src_get(mhsnd_src_get),
		   .RDY_src_get(mhsnd_RDY_src_get),
		   .RDY_sink_put(mhsnd_RDY_sink_put),
		   .RDY_newLen_put(mhsnd_RDY_newLen_put),
		   .getLen_dwm(mhsnd_getLen_dwm),
		   .RDY_getLen_dwm(),
		   .giveLen_get(),
		   .RDY_giveLen_get());

  // submodule rstndb
  SyncResetA #(.RSTDELAY(32'd15)) rstndb(.CLK(sys0_clk),
					 .IN_RST(sys0_rstn),
					 .OUT_RST(rstndb_OUT_RST));

  // submodule s2rF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) s2rF(.RST(rstndb_OUT_RST),
						.CLK(sys0_clk),
						.D_IN(s2rF_D_IN),
						.ENQ(s2rF_ENQ),
						.DEQ(s2rF_DEQ),
						.CLR(s2rF_CLR),
						.D_OUT(),
						.FULL_N(),
						.EMPTY_N());

  // rule RL_gobble
  assign CAN_FIRE_RL_gobble = 1'd1 ;
  assign WILL_FIRE_RL_gobble = 1'd1 ;

  // rule RL_cycleCount
  assign CAN_FIRE_RL_cycleCount = 1'd1 ;
  assign WILL_FIRE_RL_cycleCount = 1'd1 ;

  // rule RL_mkConnectionGetPut
  assign CAN_FIRE_RL_mkConnectionGetPut =
	     buf1_RDY_sink_put && gen1_RDY_src_get ;
  assign WILL_FIRE_RL_mkConnectionGetPut = CAN_FIRE_RL_mkConnectionGetPut ;

  // rule RL_mkConnectionGetPut_1
  assign CAN_FIRE_RL_mkConnectionGetPut_1 =
	     mhsnd_RDY_newLen_put && buf1_RDY_newLen_get ;
  assign WILL_FIRE_RL_mkConnectionGetPut_1 =
	     CAN_FIRE_RL_mkConnectionGetPut_1 ;

  // rule RL_mkConnectionGetPut_2
  assign CAN_FIRE_RL_mkConnectionGetPut_2 =
	     mhsnd_RDY_sink_put && buf1_RDY_src_get ;
  assign WILL_FIRE_RL_mkConnectionGetPut_2 =
	     CAN_FIRE_RL_mkConnectionGetPut_2 ;

  // rule RL_cnctDwm
  assign CAN_FIRE_RL_cnctDwm = buf1_RDY_length_dwm && mhsnd_getLen_dwm ;
  assign WILL_FIRE_RL_cnctDwm = CAN_FIRE_RL_cnctDwm ;

  // rule RL_mkConnectionGetPut_3
  assign CAN_FIRE_RL_mkConnectionGetPut_3 =
	     fhsnd_RDY_ingress_put && mhsnd_RDY_src_get ;
  assign WILL_FIRE_RL_mkConnectionGetPut_3 =
	     CAN_FIRE_RL_mkConnectionGetPut_3 ;

  // rule RL_mkConnectionGetPut_4
  assign CAN_FIRE_RL_mkConnectionGetPut_4 =
	     fhsnd_RDY_egress_get && fhrcv_RDY_ingress_put ;
  assign WILL_FIRE_RL_mkConnectionGetPut_4 =
	     CAN_FIRE_RL_mkConnectionGetPut_4 ;

  // rule RL_mkConnectionGetPut_5
  assign CAN_FIRE_RL_mkConnectionGetPut_5 =
	     fhrcv_RDY_egress_get && mhrcv_RDY_ingress_put ;
  assign WILL_FIRE_RL_mkConnectionGetPut_5 =
	     CAN_FIRE_RL_mkConnectionGetPut_5 ;

  // rule RL_mkConnectionGetPut_6
  assign CAN_FIRE_RL_mkConnectionGetPut_6 =
	     chk_RDY_sink1_put && mhrcv_RDY_egress_get ;
  assign WILL_FIRE_RL_mkConnectionGetPut_6 =
	     CAN_FIRE_RL_mkConnectionGetPut_6 ;

  // rule RL_mkConnectionGetPut_7
  assign CAN_FIRE_RL_mkConnectionGetPut_7 =
	     chk_RDY_sink2_put && gen2_RDY_src_get ;
  assign WILL_FIRE_RL_mkConnectionGetPut_7 =
	     CAN_FIRE_RL_mkConnectionGetPut_7 ;

  // register cycleCounter
  assign cycleCounter_D_IN = cycleCounter + 32'd1 ;
  assign cycleCounter_EN = 1'd1 ;

  // register length
  assign length_D_IN = 9'h0 ;
  assign length_EN = 1'b0 ;

  // submodule buf1
  assign buf1_sink_put = gen1_src_get ;
  assign buf1_EN_src_get = CAN_FIRE_RL_mkConnectionGetPut_2 ;
  assign buf1_EN_sink_put = CAN_FIRE_RL_mkConnectionGetPut ;
  assign buf1_EN_newLen_get = CAN_FIRE_RL_mkConnectionGetPut_1 ;
  assign buf1_EN_length_dwm = CAN_FIRE_RL_cnctDwm ;

  // submodule chk
  assign chk_sink1_put = mhrcv_egress_get ;
  assign chk_sink2_put = gen2_src_get ;
  assign chk_EN_sink1_put = CAN_FIRE_RL_mkConnectionGetPut_6 ;
  assign chk_EN_sink2_put = CAN_FIRE_RL_mkConnectionGetPut_7 ;

  // submodule fhrcv
  assign fhrcv_ingress_put = fhsnd_egress_get ;
  assign fhrcv_EN_ingress_put = CAN_FIRE_RL_mkConnectionGetPut_4 ;
  assign fhrcv_EN_egress_get = CAN_FIRE_RL_mkConnectionGetPut_5 ;

  // submodule fhsnd
  assign fhsnd_ingress_put = mhsnd_src_get ;
  assign fhsnd_EN_ingress_put = CAN_FIRE_RL_mkConnectionGetPut_3 ;
  assign fhsnd_EN_egress_get = CAN_FIRE_RL_mkConnectionGetPut_4 ;

  // submodule gen1
  assign gen1_EN_src_get = CAN_FIRE_RL_mkConnectionGetPut ;

  // submodule gen2
  assign gen2_EN_src_get = CAN_FIRE_RL_mkConnectionGetPut_7 ;

  // submodule mhrcv
  assign mhrcv_ingress_put = fhrcv_egress_get ;
  assign mhrcv_EN_ingress_put = CAN_FIRE_RL_mkConnectionGetPut_5 ;
  assign mhrcv_EN_egress_get = CAN_FIRE_RL_mkConnectionGetPut_6 ;

  // submodule mhsnd
  assign mhsnd_newLen_put = buf1_newLen_get ;
  assign mhsnd_sink_put = buf1_src_get ;
  assign mhsnd_EN_src_get = CAN_FIRE_RL_mkConnectionGetPut_3 ;
  assign mhsnd_EN_sink_put = CAN_FIRE_RL_mkConnectionGetPut_2 ;
  assign mhsnd_EN_newLen_put = CAN_FIRE_RL_mkConnectionGetPut_1 ;
  assign mhsnd_EN_giveLen_get = 1'b0 ;

  // submodule s2rF
  assign s2rF_D_IN = 33'h0 ;
  assign s2rF_ENQ = 1'b0 ;
  assign s2rF_DEQ = 1'b0 ;
  assign s2rF_CLR = 1'b0 ;

  // handling of inlined registers

  always@(posedge sys0_clk)
  begin
    if (rstndb_OUT_RST == `BSV_RESET_VALUE)
      begin
        cycleCounter <= `BSV_ASSIGNMENT_DELAY 32'd0;
	length <= `BSV_ASSIGNMENT_DELAY 9'd0;
      end
    else
      begin
        if (cycleCounter_EN)
	  cycleCounter <= `BSV_ASSIGNMENT_DELAY cycleCounter_D_IN;
	if (length_EN) length <= `BSV_ASSIGNMENT_DELAY length_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cycleCounter = 32'hAAAAAAAA;
    length = 9'h0AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge sys0_clk)
  begin
    #0;
    if (rstndb_OUT_RST != `BSV_RESET_VALUE)
      if (cycleCounter == 32'd18000) $finish(32'd1);
  end
  // synopsys translate_on
endmodule  // mkFTop_dp705

