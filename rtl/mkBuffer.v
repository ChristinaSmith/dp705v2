//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Fri Oct 19 15:35:26 EDT 2012
//
// Method conflict info:
// Method: src_get
// Conflict-free: sink_put, newLen_get, length_dwm
// Conflicts: src_get
//
// Method: sink_put
// Conflict-free: src_get, newLen_get, length_dwm
// Conflicts: sink_put
//
// Method: newLen_get
// Conflict-free: src_get, sink_put, length_dwm
// Conflicts: newLen_get
//
// Method: length_dwm
// Conflict-free: src_get, sink_put, newLen_get
// Conflicts: length_dwm
//
//
// Ports:
// Name                         I/O  size props
// src_get                        O    33 reg
// RDY_src_get                    O     1 reg
// RDY_sink_put                   O     1 reg
// newLen_get                     O     9 reg
// RDY_newLen_get                 O     1 reg
// RDY_length_dwm                 O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// sink_put                       I    33 reg
// EN_sink_put                    I     1
// EN_length_dwm                  I     1
// EN_src_get                     I     1
// EN_newLen_get                  I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBuffer(CLK,
		RST_N,

		EN_src_get,
		src_get,
		RDY_src_get,

		sink_put,
		EN_sink_put,
		RDY_sink_put,

		EN_newLen_get,
		newLen_get,
		RDY_newLen_get,

		EN_length_dwm,
		RDY_length_dwm);
  input  CLK;
  input  RST_N;

  // actionvalue method src_get
  input  EN_src_get;
  output [32 : 0] src_get;
  output RDY_src_get;

  // action method sink_put
  input  [32 : 0] sink_put;
  input  EN_sink_put;
  output RDY_sink_put;

  // actionvalue method newLen_get
  input  EN_newLen_get;
  output [8 : 0] newLen_get;
  output RDY_newLen_get;

  // action method length_dwm
  input  EN_length_dwm;
  output RDY_length_dwm;

  // signals for module outputs
  wire [32 : 0] src_get;
  wire [8 : 0] newLen_get;
  wire RDY_length_dwm, RDY_newLen_get, RDY_sink_put, RDY_src_get;

  // inlined wires
  wire [31 : 0] bram_serverAdapterB_outData_outData_wget;
  wire bram_serverAdapterA_outData_enqData_whas,
       bram_serverAdapterB_outData_enqData_whas,
       bram_serverAdapterB_outData_outData_whas;

  // register bram_serverAdapterA_cnt
  reg [2 : 0] bram_serverAdapterA_cnt;
  wire [2 : 0] bram_serverAdapterA_cnt_D_IN;
  wire bram_serverAdapterA_cnt_EN;

  // register bram_serverAdapterA_s1
  reg [1 : 0] bram_serverAdapterA_s1;
  wire [1 : 0] bram_serverAdapterA_s1_D_IN;
  wire bram_serverAdapterA_s1_EN;

  // register bram_serverAdapterB_cnt
  reg [2 : 0] bram_serverAdapterB_cnt;
  wire [2 : 0] bram_serverAdapterB_cnt_D_IN;
  wire bram_serverAdapterB_cnt_EN;

  // register bram_serverAdapterB_s1
  reg [1 : 0] bram_serverAdapterB_s1;
  wire [1 : 0] bram_serverAdapterB_s1_D_IN;
  wire bram_serverAdapterB_s1_EN;

  // register countRd
  reg [8 : 0] countRd;
  wire [8 : 0] countRd_D_IN;
  wire countRd_EN;

  // register countRdReq
  reg [8 : 0] countRdReq;
  wire [8 : 0] countRdReq_D_IN;
  wire countRdReq_EN;

  // register countWrd
  reg [8 : 0] countWrd;
  wire [8 : 0] countWrd_D_IN;
  wire countWrd_EN;

  // register firstTime
  reg firstTime;
  wire firstTime_D_IN, firstTime_EN;

  // register newMsg
  reg newMsg;
  wire newMsg_D_IN, newMsg_EN;

  // register readAddr
  reg [8 : 0] readAddr;
  wire [8 : 0] readAddr_D_IN;
  wire readAddr_EN;

  // register readCredit_value
  reg [9 : 0] readCredit_value;
  wire [9 : 0] readCredit_value_D_IN;
  wire readCredit_value_EN;

  // register writeAddr
  reg [8 : 0] writeAddr;
  wire [8 : 0] writeAddr_D_IN;
  wire writeAddr_EN;

  // ports of submodule bram_memory
  wire [31 : 0] bram_memory_DIA,
		bram_memory_DIB,
		bram_memory_DOA,
		bram_memory_DOB;
  wire [8 : 0] bram_memory_ADDRA, bram_memory_ADDRB;
  wire bram_memory_ENA, bram_memory_ENB, bram_memory_WEA, bram_memory_WEB;

  // ports of submodule bram_serverAdapterA_outDataCore
  wire [31 : 0] bram_serverAdapterA_outDataCore_D_IN;
  wire bram_serverAdapterA_outDataCore_CLR,
       bram_serverAdapterA_outDataCore_DEQ,
       bram_serverAdapterA_outDataCore_EMPTY_N,
       bram_serverAdapterA_outDataCore_ENQ,
       bram_serverAdapterA_outDataCore_FULL_N;

  // ports of submodule bram_serverAdapterB_outDataCore
  wire [31 : 0] bram_serverAdapterB_outDataCore_D_IN,
		bram_serverAdapterB_outDataCore_D_OUT;
  wire bram_serverAdapterB_outDataCore_CLR,
       bram_serverAdapterB_outDataCore_DEQ,
       bram_serverAdapterB_outDataCore_EMPTY_N,
       bram_serverAdapterB_outDataCore_ENQ,
       bram_serverAdapterB_outDataCore_FULL_N;

  // ports of submodule lenF
  wire [8 : 0] lenF_D_IN, lenF_D_OUT;
  wire lenF_CLR, lenF_DEQ, lenF_EMPTY_N, lenF_ENQ, lenF_FULL_N;

  // ports of submodule mesgInF
  wire [32 : 0] mesgInF_D_IN, mesgInF_D_OUT;
  wire mesgInF_CLR, mesgInF_DEQ, mesgInF_EMPTY_N, mesgInF_ENQ, mesgInF_FULL_N;

  // ports of submodule mesgOutF
  wire [32 : 0] mesgOutF_D_IN, mesgOutF_D_OUT;
  wire mesgOutF_CLR,
       mesgOutF_DEQ,
       mesgOutF_EMPTY_N,
       mesgOutF_ENQ,
       mesgOutF_FULL_N;

  // ports of submodule msgF
  wire [8 : 0] msgF_D_IN, msgF_D_OUT;
  wire msgF_CLR, msgF_DEQ, msgF_EMPTY_N, msgF_ENQ, msgF_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_bram_serverAdapterA_cnt_finalAdd,
       CAN_FIRE_RL_bram_serverAdapterA_moveToOutFIFO,
       CAN_FIRE_RL_bram_serverAdapterA_outData_deqOnly,
       CAN_FIRE_RL_bram_serverAdapterA_outData_enqAndDeq,
       CAN_FIRE_RL_bram_serverAdapterA_outData_enqOnly,
       CAN_FIRE_RL_bram_serverAdapterA_outData_setFirstCore,
       CAN_FIRE_RL_bram_serverAdapterA_outData_setFirstEnq,
       CAN_FIRE_RL_bram_serverAdapterA_overRun,
       CAN_FIRE_RL_bram_serverAdapterA_s1__dreg_update,
       CAN_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways,
       CAN_FIRE_RL_bram_serverAdapterB_cnt_finalAdd,
       CAN_FIRE_RL_bram_serverAdapterB_moveToOutFIFO,
       CAN_FIRE_RL_bram_serverAdapterB_outData_deqOnly,
       CAN_FIRE_RL_bram_serverAdapterB_outData_enqAndDeq,
       CAN_FIRE_RL_bram_serverAdapterB_outData_enqOnly,
       CAN_FIRE_RL_bram_serverAdapterB_outData_setFirstCore,
       CAN_FIRE_RL_bram_serverAdapterB_outData_setFirstEnq,
       CAN_FIRE_RL_bram_serverAdapterB_overRun,
       CAN_FIRE_RL_bram_serverAdapterB_s1__dreg_update,
       CAN_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways,
       CAN_FIRE_RL_newLength,
       CAN_FIRE_RL_readBRAM,
       CAN_FIRE_RL_readCredit_accumulate,
       CAN_FIRE_RL_readReqBRAM,
       CAN_FIRE_RL_writeBRAM,
       CAN_FIRE_length_dwm,
       CAN_FIRE_newLen_get,
       CAN_FIRE_sink_put,
       CAN_FIRE_src_get,
       WILL_FIRE_RL_bram_serverAdapterA_cnt_finalAdd,
       WILL_FIRE_RL_bram_serverAdapterA_moveToOutFIFO,
       WILL_FIRE_RL_bram_serverAdapterA_outData_deqOnly,
       WILL_FIRE_RL_bram_serverAdapterA_outData_enqAndDeq,
       WILL_FIRE_RL_bram_serverAdapterA_outData_enqOnly,
       WILL_FIRE_RL_bram_serverAdapterA_outData_setFirstCore,
       WILL_FIRE_RL_bram_serverAdapterA_outData_setFirstEnq,
       WILL_FIRE_RL_bram_serverAdapterA_overRun,
       WILL_FIRE_RL_bram_serverAdapterA_s1__dreg_update,
       WILL_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways,
       WILL_FIRE_RL_bram_serverAdapterB_cnt_finalAdd,
       WILL_FIRE_RL_bram_serverAdapterB_moveToOutFIFO,
       WILL_FIRE_RL_bram_serverAdapterB_outData_deqOnly,
       WILL_FIRE_RL_bram_serverAdapterB_outData_enqAndDeq,
       WILL_FIRE_RL_bram_serverAdapterB_outData_enqOnly,
       WILL_FIRE_RL_bram_serverAdapterB_outData_setFirstCore,
       WILL_FIRE_RL_bram_serverAdapterB_outData_setFirstEnq,
       WILL_FIRE_RL_bram_serverAdapterB_overRun,
       WILL_FIRE_RL_bram_serverAdapterB_s1__dreg_update,
       WILL_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways,
       WILL_FIRE_RL_newLength,
       WILL_FIRE_RL_readBRAM,
       WILL_FIRE_RL_readCredit_accumulate,
       WILL_FIRE_RL_readReqBRAM,
       WILL_FIRE_RL_writeBRAM,
       WILL_FIRE_length_dwm,
       WILL_FIRE_newLen_get,
       WILL_FIRE_sink_put,
       WILL_FIRE_src_get;

  // remaining internal signals
  wire [8 : 0] msgF_first__51_MINUS_1___d195;
  wire [2 : 0] bram_serverAdapterB_cnt_4_PLUS_IF_bram_serverA_ETC___d100;
  wire countRdReq_50_EQ_msgF_first__51_MINUS_1_60___d208,
       countRd_76_EQ_msgF_first__51_MINUS_1_60___d209;

  // actionvalue method src_get
  assign src_get = mesgOutF_D_OUT ;
  assign RDY_src_get = mesgOutF_EMPTY_N ;
  assign CAN_FIRE_src_get = mesgOutF_EMPTY_N ;
  assign WILL_FIRE_src_get = EN_src_get ;

  // action method sink_put
  assign RDY_sink_put = mesgInF_FULL_N ;
  assign CAN_FIRE_sink_put = mesgInF_FULL_N ;
  assign WILL_FIRE_sink_put = EN_sink_put ;

  // actionvalue method newLen_get
  assign newLen_get = lenF_D_OUT ;
  assign RDY_newLen_get = lenF_EMPTY_N ;
  assign CAN_FIRE_newLen_get = lenF_EMPTY_N ;
  assign WILL_FIRE_newLen_get = EN_newLen_get ;

  // action method length_dwm
  assign RDY_length_dwm = msgF_EMPTY_N ;
  assign CAN_FIRE_length_dwm = msgF_EMPTY_N ;
  assign WILL_FIRE_length_dwm = EN_length_dwm ;

  // submodule bram_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd9),
	  .DATA_WIDTH(32'd32),
	  .MEMSIZE(10'd512)) bram_memory(.CLKA(CLK),
					 .CLKB(CLK),
					 .ADDRA(bram_memory_ADDRA),
					 .ADDRB(bram_memory_ADDRB),
					 .DIA(bram_memory_DIA),
					 .DIB(bram_memory_DIB),
					 .WEA(bram_memory_WEA),
					 .WEB(bram_memory_WEB),
					 .ENA(bram_memory_ENA),
					 .ENB(bram_memory_ENB),
					 .DOA(bram_memory_DOA),
					 .DOB(bram_memory_DOB));

  // submodule bram_serverAdapterA_outDataCore
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) bram_serverAdapterA_outDataCore(.RST(RST_N),
							       .CLK(CLK),
							       .D_IN(bram_serverAdapterA_outDataCore_D_IN),
							       .ENQ(bram_serverAdapterA_outDataCore_ENQ),
							       .DEQ(bram_serverAdapterA_outDataCore_DEQ),
							       .CLR(bram_serverAdapterA_outDataCore_CLR),
							       .D_OUT(),
							       .FULL_N(bram_serverAdapterA_outDataCore_FULL_N),
							       .EMPTY_N(bram_serverAdapterA_outDataCore_EMPTY_N));

  // submodule bram_serverAdapterB_outDataCore
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) bram_serverAdapterB_outDataCore(.RST(RST_N),
							       .CLK(CLK),
							       .D_IN(bram_serverAdapterB_outDataCore_D_IN),
							       .ENQ(bram_serverAdapterB_outDataCore_ENQ),
							       .DEQ(bram_serverAdapterB_outDataCore_DEQ),
							       .CLR(bram_serverAdapterB_outDataCore_CLR),
							       .D_OUT(bram_serverAdapterB_outDataCore_D_OUT),
							       .FULL_N(bram_serverAdapterB_outDataCore_FULL_N),
							       .EMPTY_N(bram_serverAdapterB_outDataCore_EMPTY_N));

  // submodule lenF
  FIFO2 #(.width(32'd9), .guarded(32'd1)) lenF(.RST(RST_N),
					       .CLK(CLK),
					       .D_IN(lenF_D_IN),
					       .ENQ(lenF_ENQ),
					       .DEQ(lenF_DEQ),
					       .CLR(lenF_CLR),
					       .D_OUT(lenF_D_OUT),
					       .FULL_N(lenF_FULL_N),
					       .EMPTY_N(lenF_EMPTY_N));

  // submodule mesgInF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) mesgInF(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(mesgInF_D_IN),
						   .ENQ(mesgInF_ENQ),
						   .DEQ(mesgInF_DEQ),
						   .CLR(mesgInF_CLR),
						   .D_OUT(mesgInF_D_OUT),
						   .FULL_N(mesgInF_FULL_N),
						   .EMPTY_N(mesgInF_EMPTY_N));

  // submodule mesgOutF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) mesgOutF(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(mesgOutF_D_IN),
						    .ENQ(mesgOutF_ENQ),
						    .DEQ(mesgOutF_DEQ),
						    .CLR(mesgOutF_CLR),
						    .D_OUT(mesgOutF_D_OUT),
						    .FULL_N(mesgOutF_FULL_N),
						    .EMPTY_N(mesgOutF_EMPTY_N));

  // submodule msgF
  FIFO1 #(.width(32'd9), .guarded(32'd1)) msgF(.RST(RST_N),
					       .CLK(CLK),
					       .D_IN(msgF_D_IN),
					       .ENQ(msgF_ENQ),
					       .DEQ(msgF_DEQ),
					       .CLR(msgF_CLR),
					       .D_OUT(msgF_D_OUT),
					       .FULL_N(msgF_FULL_N),
					       .EMPTY_N(msgF_EMPTY_N));

  // rule RL_writeBRAM
  assign CAN_FIRE_RL_writeBRAM =
	     CAN_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways ;
  assign WILL_FIRE_RL_writeBRAM =
	     CAN_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways ;

  // rule RL_readReqBRAM
  assign CAN_FIRE_RL_readReqBRAM =
	     CAN_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways ;
  assign WILL_FIRE_RL_readReqBRAM =
	     CAN_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways ;

  // rule RL_newLength
  assign CAN_FIRE_RL_newLength = msgF_EMPTY_N && lenF_FULL_N && newMsg ;
  assign WILL_FIRE_RL_newLength = CAN_FIRE_RL_newLength ;

  // rule RL_readCredit_accumulate
  assign CAN_FIRE_RL_readCredit_accumulate = 1'd1 ;
  assign WILL_FIRE_RL_readCredit_accumulate = 1'd1 ;

  // rule RL_bram_serverAdapterA_stageReadResponseAlways
  assign CAN_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways =
	     mesgInF_EMPTY_N && (bram_serverAdapterA_cnt ^ 3'h4) < 3'd7 &&
	     (!mesgInF_D_OUT[32] || msgF_FULL_N) ;
  assign WILL_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways =
	     CAN_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways ;

  // rule RL_bram_serverAdapterA_moveToOutFIFO
  assign CAN_FIRE_RL_bram_serverAdapterA_moveToOutFIFO =
	     (!bram_serverAdapterA_s1[0] ||
	      bram_serverAdapterA_outDataCore_FULL_N) &&
	     bram_serverAdapterA_s1[1] ;
  assign WILL_FIRE_RL_bram_serverAdapterA_moveToOutFIFO =
	     CAN_FIRE_RL_bram_serverAdapterA_moveToOutFIFO ;

  // rule RL_bram_serverAdapterA_overRun
  assign CAN_FIRE_RL_bram_serverAdapterA_overRun =
	     bram_serverAdapterA_s1[1] &&
	     !bram_serverAdapterA_outDataCore_FULL_N ;
  assign WILL_FIRE_RL_bram_serverAdapterA_overRun =
	     CAN_FIRE_RL_bram_serverAdapterA_overRun ;

  // rule RL_bram_serverAdapterA_outData_setFirstCore
  assign CAN_FIRE_RL_bram_serverAdapterA_outData_setFirstCore =
	     bram_serverAdapterA_outDataCore_EMPTY_N ;
  assign WILL_FIRE_RL_bram_serverAdapterA_outData_setFirstCore =
	     bram_serverAdapterA_outDataCore_EMPTY_N ;

  // rule RL_bram_serverAdapterA_outData_setFirstEnq
  assign CAN_FIRE_RL_bram_serverAdapterA_outData_setFirstEnq =
	     !bram_serverAdapterA_outDataCore_EMPTY_N &&
	     bram_serverAdapterA_outData_enqData_whas ;
  assign WILL_FIRE_RL_bram_serverAdapterA_outData_setFirstEnq =
	     CAN_FIRE_RL_bram_serverAdapterA_outData_setFirstEnq ;

  // rule RL_bram_serverAdapterA_outData_enqOnly
  assign CAN_FIRE_RL_bram_serverAdapterA_outData_enqOnly =
	     bram_serverAdapterA_outDataCore_FULL_N &&
	     bram_serverAdapterA_outData_enqData_whas ;
  assign WILL_FIRE_RL_bram_serverAdapterA_outData_enqOnly =
	     CAN_FIRE_RL_bram_serverAdapterA_outData_enqOnly ;

  // rule RL_bram_serverAdapterA_outData_deqOnly
  assign CAN_FIRE_RL_bram_serverAdapterA_outData_deqOnly = 1'b0 ;
  assign WILL_FIRE_RL_bram_serverAdapterA_outData_deqOnly = 1'b0 ;

  // rule RL_bram_serverAdapterA_outData_enqAndDeq
  assign CAN_FIRE_RL_bram_serverAdapterA_outData_enqAndDeq = 1'b0 ;
  assign WILL_FIRE_RL_bram_serverAdapterA_outData_enqAndDeq = 1'b0 ;

  // rule RL_bram_serverAdapterA_cnt_finalAdd
  assign CAN_FIRE_RL_bram_serverAdapterA_cnt_finalAdd = 1'b0 ;
  assign WILL_FIRE_RL_bram_serverAdapterA_cnt_finalAdd = 1'b0 ;

  // rule RL_bram_serverAdapterA_s1__dreg_update
  assign CAN_FIRE_RL_bram_serverAdapterA_s1__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_bram_serverAdapterA_s1__dreg_update = 1'd1 ;

  // rule RL_bram_serverAdapterB_stageReadResponseAlways
  assign CAN_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways =
	     msgF_EMPTY_N && (bram_serverAdapterB_cnt ^ 3'h4) < 3'd7 &&
	     countRdReq < msgF_D_OUT &&
	     (readCredit_value ^ 10'h200) > 10'd512 &&
	     firstTime ;
  assign WILL_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways =
	     CAN_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways ;

  // rule RL_bram_serverAdapterB_moveToOutFIFO
  assign CAN_FIRE_RL_bram_serverAdapterB_moveToOutFIFO =
	     (!bram_serverAdapterB_s1[0] ||
	      bram_serverAdapterB_outDataCore_FULL_N) &&
	     bram_serverAdapterB_s1[1] ;
  assign WILL_FIRE_RL_bram_serverAdapterB_moveToOutFIFO =
	     CAN_FIRE_RL_bram_serverAdapterB_moveToOutFIFO ;

  // rule RL_bram_serverAdapterB_overRun
  assign CAN_FIRE_RL_bram_serverAdapterB_overRun =
	     bram_serverAdapterB_s1[1] &&
	     !bram_serverAdapterB_outDataCore_FULL_N ;
  assign WILL_FIRE_RL_bram_serverAdapterB_overRun =
	     CAN_FIRE_RL_bram_serverAdapterB_overRun ;

  // rule RL_bram_serverAdapterB_outData_setFirstCore
  assign CAN_FIRE_RL_bram_serverAdapterB_outData_setFirstCore =
	     bram_serverAdapterB_outDataCore_EMPTY_N ;
  assign WILL_FIRE_RL_bram_serverAdapterB_outData_setFirstCore =
	     bram_serverAdapterB_outDataCore_EMPTY_N ;

  // rule RL_bram_serverAdapterB_outData_setFirstEnq
  assign CAN_FIRE_RL_bram_serverAdapterB_outData_setFirstEnq =
	     !bram_serverAdapterB_outDataCore_EMPTY_N &&
	     bram_serverAdapterB_outData_enqData_whas ;
  assign WILL_FIRE_RL_bram_serverAdapterB_outData_setFirstEnq =
	     CAN_FIRE_RL_bram_serverAdapterB_outData_setFirstEnq ;

  // rule RL_readBRAM
  assign CAN_FIRE_RL_readBRAM =
	     msgF_EMPTY_N &&
	     (bram_serverAdapterB_outDataCore_EMPTY_N ||
	      bram_serverAdapterB_outData_enqData_whas) &&
	     mesgOutF_FULL_N &&
	     bram_serverAdapterB_outData_outData_whas ;
  assign WILL_FIRE_RL_readBRAM = CAN_FIRE_RL_readBRAM ;

  // rule RL_bram_serverAdapterB_outData_enqOnly
  assign CAN_FIRE_RL_bram_serverAdapterB_outData_enqOnly =
	     bram_serverAdapterB_outDataCore_FULL_N &&
	     !CAN_FIRE_RL_readBRAM &&
	     bram_serverAdapterB_outData_enqData_whas ;
  assign WILL_FIRE_RL_bram_serverAdapterB_outData_enqOnly =
	     CAN_FIRE_RL_bram_serverAdapterB_outData_enqOnly ;

  // rule RL_bram_serverAdapterB_outData_deqOnly
  assign CAN_FIRE_RL_bram_serverAdapterB_outData_deqOnly =
	     bram_serverAdapterB_outDataCore_EMPTY_N &&
	     CAN_FIRE_RL_readBRAM &&
	     !bram_serverAdapterB_outData_enqData_whas ;
  assign WILL_FIRE_RL_bram_serverAdapterB_outData_deqOnly =
	     CAN_FIRE_RL_bram_serverAdapterB_outData_deqOnly ;

  // rule RL_bram_serverAdapterB_outData_enqAndDeq
  assign CAN_FIRE_RL_bram_serverAdapterB_outData_enqAndDeq =
	     bram_serverAdapterB_outDataCore_EMPTY_N &&
	     bram_serverAdapterB_outDataCore_FULL_N &&
	     CAN_FIRE_RL_readBRAM &&
	     bram_serverAdapterB_outData_enqData_whas ;
  assign WILL_FIRE_RL_bram_serverAdapterB_outData_enqAndDeq =
	     CAN_FIRE_RL_bram_serverAdapterB_outData_enqAndDeq ;

  // rule RL_bram_serverAdapterB_cnt_finalAdd
  assign CAN_FIRE_RL_bram_serverAdapterB_cnt_finalAdd =
	     WILL_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways ||
	     CAN_FIRE_RL_readBRAM ;
  assign WILL_FIRE_RL_bram_serverAdapterB_cnt_finalAdd =
	     CAN_FIRE_RL_bram_serverAdapterB_cnt_finalAdd ;

  // rule RL_bram_serverAdapterB_s1__dreg_update
  assign CAN_FIRE_RL_bram_serverAdapterB_s1__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_bram_serverAdapterB_s1__dreg_update = 1'd1 ;

  // inlined wires
  assign bram_serverAdapterA_outData_enqData_whas =
	     WILL_FIRE_RL_bram_serverAdapterA_moveToOutFIFO &&
	     bram_serverAdapterA_s1[0] ;
  assign bram_serverAdapterB_outData_enqData_whas =
	     WILL_FIRE_RL_bram_serverAdapterB_moveToOutFIFO &&
	     bram_serverAdapterB_s1[0] ;
  assign bram_serverAdapterB_outData_outData_wget =
	     bram_serverAdapterB_outDataCore_EMPTY_N ?
	       bram_serverAdapterB_outDataCore_D_OUT :
	       bram_memory_DOB ;
  assign bram_serverAdapterB_outData_outData_whas =
	     bram_serverAdapterB_outDataCore_EMPTY_N ||
	     WILL_FIRE_RL_bram_serverAdapterB_outData_setFirstEnq ;

  // register bram_serverAdapterA_cnt
  assign bram_serverAdapterA_cnt_D_IN =
	     bram_serverAdapterA_cnt + 3'd0 + 3'd0 ;
  assign bram_serverAdapterA_cnt_EN = 1'b0 ;

  // register bram_serverAdapterA_s1
  assign bram_serverAdapterA_s1_D_IN =
	     { CAN_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways,
	       1'b0 } ;
  assign bram_serverAdapterA_s1_EN = 1'd1 ;

  // register bram_serverAdapterB_cnt
  assign bram_serverAdapterB_cnt_D_IN =
	     bram_serverAdapterB_cnt_4_PLUS_IF_bram_serverA_ETC___d100 ;
  assign bram_serverAdapterB_cnt_EN =
	     CAN_FIRE_RL_bram_serverAdapterB_cnt_finalAdd ;

  // register bram_serverAdapterB_s1
  assign bram_serverAdapterB_s1_D_IN =
	     { CAN_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways,
	       1'b1 } ;
  assign bram_serverAdapterB_s1_EN = 1'd1 ;

  // register countRd
  assign countRd_D_IN =
	     countRd_76_EQ_msgF_first__51_MINUS_1_60___d209 ?
	       9'd0 :
	       countRd + 9'd1 ;
  assign countRd_EN = CAN_FIRE_RL_readBRAM ;

  // register countRdReq
  assign countRdReq_D_IN =
	     countRdReq_50_EQ_msgF_first__51_MINUS_1_60___d208 ?
	       9'd0 :
	       countRdReq + 9'd1 ;
  assign countRdReq_EN =
	     CAN_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways ;

  // register countWrd
  assign countWrd_D_IN = mesgInF_D_OUT[32] ? 9'd1 : countWrd + 9'd1 ;
  assign countWrd_EN =
	     CAN_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways ;

  // register firstTime
  assign firstTime_D_IN =
	     EN_length_dwm ||
	     !countRdReq_50_EQ_msgF_first__51_MINUS_1_60___d208 ;
  assign firstTime_EN = WILL_FIRE_RL_readReqBRAM || EN_length_dwm ;

  // register newMsg
  assign newMsg_D_IN = EN_length_dwm ;
  assign newMsg_EN = WILL_FIRE_RL_newLength || EN_length_dwm ;

  // register readAddr
  assign readAddr_D_IN =
	     countRdReq_50_EQ_msgF_first__51_MINUS_1_60___d208 ?
	       { ~readAddr[8], 8'd0 } :
	       readAddr + 9'd1 ;
  assign readAddr_EN =
	     CAN_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways ;

  // register readCredit_value
  assign readCredit_value_D_IN =
	     readCredit_value +
	     (CAN_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways ?
		10'd1 :
		10'd0) +
	     (CAN_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways ?
		10'd1023 :
		10'd0) ;
  assign readCredit_value_EN = 1'd1 ;

  // register writeAddr
  assign writeAddr_D_IN =
	     mesgInF_D_OUT[32] ? { ~writeAddr[8], 8'd0 } : writeAddr + 9'd1 ;
  assign writeAddr_EN =
	     CAN_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways ;

  // submodule bram_memory
  assign bram_memory_ADDRA = writeAddr ;
  assign bram_memory_ADDRB = readAddr ;
  assign bram_memory_DIA = mesgInF_D_OUT[31:0] ;
  assign bram_memory_DIB = 32'd0 ;
  assign bram_memory_WEA = 1'd1 ;
  assign bram_memory_WEB = 1'd0 ;
  assign bram_memory_ENA =
	     CAN_FIRE_RL_bram_serverAdapterA_stageReadResponseAlways ;
  assign bram_memory_ENB =
	     CAN_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways ;

  // submodule bram_serverAdapterA_outDataCore
  assign bram_serverAdapterA_outDataCore_D_IN = bram_memory_DOA ;
  assign bram_serverAdapterA_outDataCore_ENQ =
	     WILL_FIRE_RL_bram_serverAdapterA_outData_enqOnly ;
  assign bram_serverAdapterA_outDataCore_DEQ = 1'b0 ;
  assign bram_serverAdapterA_outDataCore_CLR = 1'b0 ;

  // submodule bram_serverAdapterB_outDataCore
  assign bram_serverAdapterB_outDataCore_D_IN = bram_memory_DOB ;
  assign bram_serverAdapterB_outDataCore_ENQ =
	     WILL_FIRE_RL_bram_serverAdapterB_outData_enqAndDeq ||
	     WILL_FIRE_RL_bram_serverAdapterB_outData_enqOnly ;
  assign bram_serverAdapterB_outDataCore_DEQ =
	     WILL_FIRE_RL_bram_serverAdapterB_outData_enqAndDeq ||
	     WILL_FIRE_RL_bram_serverAdapterB_outData_deqOnly ;
  assign bram_serverAdapterB_outDataCore_CLR = 1'b0 ;

  // submodule lenF
  assign lenF_D_IN = msgF_D_OUT ;
  assign lenF_ENQ = CAN_FIRE_RL_newLength ;
  assign lenF_DEQ = EN_newLen_get ;
  assign lenF_CLR = 1'b0 ;

  // submodule mesgInF
  assign mesgInF_D_IN = sink_put ;
  assign mesgInF_ENQ = EN_sink_put ;
  assign mesgInF_DEQ =
	     mesgInF_EMPTY_N && (bram_serverAdapterA_cnt ^ 3'h4) < 3'd7 &&
	     (!mesgInF_D_OUT[32] || msgF_FULL_N) ;
  assign mesgInF_CLR = 1'b0 ;

  // submodule mesgOutF
  assign mesgOutF_D_IN =
	     { countRd_76_EQ_msgF_first__51_MINUS_1_60___d209,
	       bram_serverAdapterB_outData_outData_wget } ;
  assign mesgOutF_ENQ =
	     msgF_EMPTY_N &&
	     (bram_serverAdapterB_outDataCore_EMPTY_N ||
	      bram_serverAdapterB_outData_enqData_whas) &&
	     mesgOutF_FULL_N &&
	     bram_serverAdapterB_outData_outData_whas ;
  assign mesgOutF_DEQ = EN_src_get ;
  assign mesgOutF_CLR = 1'b0 ;

  // submodule msgF
  assign msgF_D_IN = countWrd ;
  assign msgF_ENQ = WILL_FIRE_RL_writeBRAM && mesgInF_D_OUT[32] ;
  assign msgF_DEQ = EN_length_dwm ;
  assign msgF_CLR = 1'b0 ;

  // remaining internal signals
  assign bram_serverAdapterB_cnt_4_PLUS_IF_bram_serverA_ETC___d100 =
	     bram_serverAdapterB_cnt +
	     (WILL_FIRE_RL_bram_serverAdapterB_stageReadResponseAlways ?
		3'd1 :
		3'd0) +
	     (CAN_FIRE_RL_readBRAM ? 3'd7 : 3'd0) ;
  assign countRdReq_50_EQ_msgF_first__51_MINUS_1_60___d208 =
	     countRdReq == msgF_first__51_MINUS_1___d195 ;
  assign countRd_76_EQ_msgF_first__51_MINUS_1_60___d209 =
	     countRd == msgF_first__51_MINUS_1___d195 ;
  assign msgF_first__51_MINUS_1___d195 = msgF_D_OUT - 9'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        bram_serverAdapterA_cnt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	bram_serverAdapterA_s1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	bram_serverAdapterB_cnt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	bram_serverAdapterB_s1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	countRd <= `BSV_ASSIGNMENT_DELAY 9'd0;
	countRdReq <= `BSV_ASSIGNMENT_DELAY 9'd0;
	countWrd <= `BSV_ASSIGNMENT_DELAY 9'd1;
	firstTime <= `BSV_ASSIGNMENT_DELAY 1'd1;
	newMsg <= `BSV_ASSIGNMENT_DELAY 1'd1;
	readAddr <= `BSV_ASSIGNMENT_DELAY 9'd0;
	readCredit_value <= `BSV_ASSIGNMENT_DELAY 10'd0;
	writeAddr <= `BSV_ASSIGNMENT_DELAY 9'd0;
      end
    else
      begin
        if (bram_serverAdapterA_cnt_EN)
	  bram_serverAdapterA_cnt <= `BSV_ASSIGNMENT_DELAY
	      bram_serverAdapterA_cnt_D_IN;
	if (bram_serverAdapterA_s1_EN)
	  bram_serverAdapterA_s1 <= `BSV_ASSIGNMENT_DELAY
	      bram_serverAdapterA_s1_D_IN;
	if (bram_serverAdapterB_cnt_EN)
	  bram_serverAdapterB_cnt <= `BSV_ASSIGNMENT_DELAY
	      bram_serverAdapterB_cnt_D_IN;
	if (bram_serverAdapterB_s1_EN)
	  bram_serverAdapterB_s1 <= `BSV_ASSIGNMENT_DELAY
	      bram_serverAdapterB_s1_D_IN;
	if (countRd_EN) countRd <= `BSV_ASSIGNMENT_DELAY countRd_D_IN;
	if (countRdReq_EN)
	  countRdReq <= `BSV_ASSIGNMENT_DELAY countRdReq_D_IN;
	if (countWrd_EN) countWrd <= `BSV_ASSIGNMENT_DELAY countWrd_D_IN;
	if (firstTime_EN) firstTime <= `BSV_ASSIGNMENT_DELAY firstTime_D_IN;
	if (newMsg_EN) newMsg <= `BSV_ASSIGNMENT_DELAY newMsg_D_IN;
	if (readAddr_EN) readAddr <= `BSV_ASSIGNMENT_DELAY readAddr_D_IN;
	if (readCredit_value_EN)
	  readCredit_value <= `BSV_ASSIGNMENT_DELAY readCredit_value_D_IN;
	if (writeAddr_EN) writeAddr <= `BSV_ASSIGNMENT_DELAY writeAddr_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    bram_serverAdapterA_cnt = 3'h2;
    bram_serverAdapterA_s1 = 2'h2;
    bram_serverAdapterB_cnt = 3'h2;
    bram_serverAdapterB_s1 = 2'h2;
    countRd = 9'h0AA;
    countRdReq = 9'h0AA;
    countWrd = 9'h0AA;
    firstTime = 1'h0;
    newMsg = 1'h0;
    readAddr = 9'h0AA;
    readCredit_value = 10'h2AA;
    writeAddr = 9'h0AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_bram_serverAdapterA_overRun)
	$display("ERROR: %m: mkBRAMSeverAdapter overrun");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_bram_serverAdapterB_overRun)
	$display("ERROR: %m: mkBRAMSeverAdapter overrun");
  end
  // synopsys translate_on
endmodule  // mkBuffer

