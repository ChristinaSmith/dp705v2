//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Fri Oct 19 15:35:25 EDT 2012
//
// Method conflict info:
// Method: src_get
// Conflicts: src_get
//
//
// Ports:
// Name                         I/O  size props
// src_get                        O    33 reg
// RDY_src_get                    O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// EN_src_get                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkGenerator(CLK,
		   RST_N,

		   EN_src_get,
		   src_get,
		   RDY_src_get);
  input  CLK;
  input  RST_N;

  // actionvalue method src_get
  input  EN_src_get;
  output [32 : 0] src_get;
  output RDY_src_get;

  // signals for module outputs
  wire [32 : 0] src_get;
  wire RDY_src_get;

  // register count
  reg [8 : 0] count;
  wire [8 : 0] count_D_IN;
  wire count_EN;

  // register initV
  reg [31 : 0] initV;
  wire [31 : 0] initV_D_IN;
  wire initV_EN;

  // register lfsr_r
  reg [31 : 0] lfsr_r;
  wire [31 : 0] lfsr_r_D_IN;
  wire lfsr_r_EN;

  // register maxLen
  reg [8 : 0] maxLen;
  wire [8 : 0] maxLen_D_IN;
  wire maxLen_EN;

  // register mesgLen
  reg [8 : 0] mesgLen;
  wire [8 : 0] mesgLen_D_IN;
  wire mesgLen_EN;

  // register minLen
  reg [8 : 0] minLen;
  wire [8 : 0] minLen_D_IN;
  wire minLen_EN;

  // register patternV
  reg [31 : 0] patternV;
  wire [31 : 0] patternV_D_IN;
  wire patternV_EN;

  // register seedLFSR
  reg seedLFSR;
  wire seedLFSR_D_IN, seedLFSR_EN;

  // register startLFSR
  reg startLFSR;
  wire startLFSR_D_IN, startLFSR_EN;

  // register tmp
  reg tmp;
  wire tmp_D_IN, tmp_EN;

  // ports of submodule mesgOutF
  wire [32 : 0] mesgOutF_D_IN, mesgOutF_D_OUT;
  wire mesgOutF_CLR,
       mesgOutF_DEQ,
       mesgOutF_EMPTY_N,
       mesgOutF_ENQ,
       mesgOutF_FULL_N;

  // ports of submodule randomF
  wire [8 : 0] randomF_D_IN, randomF_D_OUT;
  wire randomF_CLR, randomF_DEQ, randomF_EMPTY_N, randomF_ENQ, randomF_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_genMesgEOP,
       CAN_FIRE_RL_genMesgNotEOP,
       CAN_FIRE_RL_setMsgLen,
       CAN_FIRE_RL_setupLFSR,
       CAN_FIRE_src_get,
       WILL_FIRE_RL_genMesgEOP,
       WILL_FIRE_RL_genMesgNotEOP,
       WILL_FIRE_RL_setMsgLen,
       WILL_FIRE_RL_setupLFSR,
       WILL_FIRE_src_get;

  // inputs to muxes for submodule ports
  wire [32 : 0] MUX_mesgOutF_enq_1__VAL_1, MUX_mesgOutF_enq_1__VAL_2;
  wire [31 : 0] MUX_lfsr_r_write_1__VAL_2, MUX_patternV_write_1__VAL_2;
  wire [8 : 0] MUX_count_write_1__VAL_1;
  wire MUX_mesgOutF_enq_1__SEL_1, MUX_mesgOutF_enq_1__SEL_2;

  // remaining internal signals
  wire [8 : 0] mesgLen_8_MINUS_1___d73;
  wire lfsr_r_BITS_31_TO_23_ULT_255___d5;

  // actionvalue method src_get
  assign src_get = mesgOutF_D_OUT ;
  assign RDY_src_get = mesgOutF_EMPTY_N ;
  assign CAN_FIRE_src_get = mesgOutF_EMPTY_N ;
  assign WILL_FIRE_src_get = EN_src_get ;

  // submodule mesgOutF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) mesgOutF(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(mesgOutF_D_IN),
						    .ENQ(mesgOutF_ENQ),
						    .DEQ(mesgOutF_DEQ),
						    .CLR(mesgOutF_CLR),
						    .D_OUT(mesgOutF_D_OUT),
						    .FULL_N(mesgOutF_FULL_N),
						    .EMPTY_N(mesgOutF_EMPTY_N));

  // submodule randomF
  FIFO2 #(.width(32'd9), .guarded(32'd1)) randomF(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(randomF_D_IN),
						  .ENQ(randomF_ENQ),
						  .DEQ(randomF_DEQ),
						  .CLR(randomF_CLR),
						  .D_OUT(randomF_D_OUT),
						  .FULL_N(randomF_FULL_N),
						  .EMPTY_N(randomF_EMPTY_N));

  // rule RL_setMsgLen
  assign CAN_FIRE_RL_setMsgLen =
	     (lfsr_r[31:23] == 9'd0 || !lfsr_r_BITS_31_TO_23_ULT_255___d5 ||
	      randomF_FULL_N) &&
	     startLFSR ;
  assign WILL_FIRE_RL_setMsgLen = CAN_FIRE_RL_setMsgLen ;

  // rule RL_setupLFSR
  assign CAN_FIRE_RL_setupLFSR = seedLFSR ;
  assign WILL_FIRE_RL_setupLFSR = seedLFSR ;

  // rule RL_genMesgNotEOP
  assign CAN_FIRE_RL_genMesgNotEOP = MUX_mesgOutF_enq_1__SEL_1 ;
  assign WILL_FIRE_RL_genMesgNotEOP = MUX_mesgOutF_enq_1__SEL_1 ;

  // rule RL_genMesgEOP
  assign CAN_FIRE_RL_genMesgEOP = MUX_mesgOutF_enq_1__SEL_2 ;
  assign WILL_FIRE_RL_genMesgEOP = MUX_mesgOutF_enq_1__SEL_2 ;

  // inputs to muxes for submodule ports
  assign MUX_mesgOutF_enq_1__SEL_1 =
	     mesgOutF_FULL_N && count < mesgLen_8_MINUS_1___d73 ;
  assign MUX_mesgOutF_enq_1__SEL_2 =
	     mesgOutF_FULL_N && randomF_EMPTY_N &&
	     count == mesgLen_8_MINUS_1___d73 ;
  assign MUX_count_write_1__VAL_1 = count + 9'd1 ;
  assign MUX_lfsr_r_write_1__VAL_2 =
	     lfsr_r[0] ?
	       { 1'd1,
		 lfsr_r[31:8],
		 ~lfsr_r[7],
		 lfsr_r[6],
		 ~lfsr_r[5],
		 lfsr_r[4],
		 ~lfsr_r[3:1] } :
	       { 1'd0, lfsr_r[31:1] } ;
  assign MUX_mesgOutF_enq_1__VAL_1 = { 1'd0, patternV } ;
  assign MUX_mesgOutF_enq_1__VAL_2 = { 1'd1, patternV } ;
  assign MUX_patternV_write_1__VAL_2 =
	     { 8'd4 + patternV[31:24],
	       8'd4 + patternV[23:16],
	       8'd4 + patternV[15:8],
	       8'd4 + patternV[7:0] } ;

  // register count
  assign count_D_IN =
	     WILL_FIRE_RL_genMesgNotEOP ? MUX_count_write_1__VAL_1 : 9'd0 ;
  assign count_EN = WILL_FIRE_RL_genMesgNotEOP || WILL_FIRE_RL_genMesgEOP ;

  // register initV
  assign initV_D_IN =
	     { 8'd1 + initV[31:24],
	       8'd1 + initV[23:16],
	       8'd1 + initV[15:8],
	       8'd1 + initV[7:0] } ;
  assign initV_EN = MUX_mesgOutF_enq_1__SEL_2 ;

  // register lfsr_r
  assign lfsr_r_D_IN = seedLFSR ? 32'h55555555 : MUX_lfsr_r_write_1__VAL_2 ;
  assign lfsr_r_EN = WILL_FIRE_RL_setMsgLen || seedLFSR ;

  // register maxLen
  assign maxLen_D_IN = (lfsr_r[31:23] <= maxLen) ? maxLen : lfsr_r[31:23] ;
  assign maxLen_EN =
	     WILL_FIRE_RL_setMsgLen && lfsr_r[31:23] != 9'd0 &&
	     lfsr_r_BITS_31_TO_23_ULT_255___d5 ;

  // register mesgLen
  assign mesgLen_D_IN = randomF_D_OUT ;
  assign mesgLen_EN = MUX_mesgOutF_enq_1__SEL_2 ;

  // register minLen
  assign minLen_D_IN = (lfsr_r[31:23] < minLen) ? lfsr_r[31:23] : minLen ;
  assign minLen_EN =
	     WILL_FIRE_RL_setMsgLen && lfsr_r[31:23] != 9'd0 &&
	     lfsr_r_BITS_31_TO_23_ULT_255___d5 ;

  // register patternV
  assign patternV_D_IN =
	     WILL_FIRE_RL_genMesgEOP ? initV : MUX_patternV_write_1__VAL_2 ;
  assign patternV_EN = WILL_FIRE_RL_genMesgEOP || WILL_FIRE_RL_genMesgNotEOP ;

  // register seedLFSR
  assign seedLFSR_D_IN = 1'd0 ;
  assign seedLFSR_EN = seedLFSR ;

  // register startLFSR
  assign startLFSR_D_IN = 1'd1 ;
  assign startLFSR_EN = seedLFSR ;

  // register tmp
  assign tmp_D_IN = 1'b0 ;
  assign tmp_EN = 1'b0 ;

  // submodule mesgOutF
  assign mesgOutF_D_IN =
	     WILL_FIRE_RL_genMesgNotEOP ?
	       MUX_mesgOutF_enq_1__VAL_1 :
	       MUX_mesgOutF_enq_1__VAL_2 ;
  assign mesgOutF_ENQ =
	     WILL_FIRE_RL_genMesgNotEOP || WILL_FIRE_RL_genMesgEOP ;
  assign mesgOutF_DEQ = EN_src_get ;
  assign mesgOutF_CLR = 1'b0 ;

  // submodule randomF
  assign randomF_D_IN = lfsr_r[31:23] ;
  assign randomF_ENQ =
	     WILL_FIRE_RL_setMsgLen && lfsr_r[31:23] != 9'd0 &&
	     lfsr_r_BITS_31_TO_23_ULT_255___d5 ;
  assign randomF_DEQ = MUX_mesgOutF_enq_1__SEL_2 ;
  assign randomF_CLR = 1'b0 ;

  // remaining internal signals
  assign lfsr_r_BITS_31_TO_23_ULT_255___d5 = lfsr_r[31:23] < 9'd255 ;
  assign mesgLen_8_MINUS_1___d73 = mesgLen - 9'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        count <= `BSV_ASSIGNMENT_DELAY 9'd0;
	initV <= `BSV_ASSIGNMENT_DELAY 32'd16909060;
	lfsr_r <= `BSV_ASSIGNMENT_DELAY 32'd1;
	maxLen <= `BSV_ASSIGNMENT_DELAY 9'd0;
	mesgLen <= `BSV_ASSIGNMENT_DELAY 9'd10;
	minLen <= `BSV_ASSIGNMENT_DELAY 9'd511;
	patternV <= `BSV_ASSIGNMENT_DELAY 32'd66051;
	seedLFSR <= `BSV_ASSIGNMENT_DELAY 1'd1;
	startLFSR <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tmp <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (count_EN) count <= `BSV_ASSIGNMENT_DELAY count_D_IN;
	if (initV_EN) initV <= `BSV_ASSIGNMENT_DELAY initV_D_IN;
	if (lfsr_r_EN) lfsr_r <= `BSV_ASSIGNMENT_DELAY lfsr_r_D_IN;
	if (maxLen_EN) maxLen <= `BSV_ASSIGNMENT_DELAY maxLen_D_IN;
	if (mesgLen_EN) mesgLen <= `BSV_ASSIGNMENT_DELAY mesgLen_D_IN;
	if (minLen_EN) minLen <= `BSV_ASSIGNMENT_DELAY minLen_D_IN;
	if (patternV_EN) patternV <= `BSV_ASSIGNMENT_DELAY patternV_D_IN;
	if (seedLFSR_EN) seedLFSR <= `BSV_ASSIGNMENT_DELAY seedLFSR_D_IN;
	if (startLFSR_EN) startLFSR <= `BSV_ASSIGNMENT_DELAY startLFSR_D_IN;
	if (tmp_EN) tmp <= `BSV_ASSIGNMENT_DELAY tmp_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    count = 9'h0AA;
    initV = 32'hAAAAAAAA;
    lfsr_r = 32'hAAAAAAAA;
    maxLen = 9'h0AA;
    mesgLen = 9'h0AA;
    minLen = 9'h0AA;
    patternV = 32'hAAAAAAAA;
    seedLFSR = 1'h0;
    startLFSR = 1'h0;
    tmp = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkGenerator

