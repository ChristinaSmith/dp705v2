//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Fri Oct 19 15:35:24 EDT 2012
//
// Method conflict info:
// Method: src_get
// Conflict-free: sink_put, newLen_put, getLen_dwm, giveLen_get
// Conflicts: src_get
//
// Method: sink_put
// Conflict-free: src_get, newLen_put, getLen_dwm, giveLen_get
// Conflicts: sink_put
//
// Method: newLen_put
// Conflict-free: src_get, sink_put, getLen_dwm, giveLen_get
// Conflicts: newLen_put
//
// Method: getLen_dwm
// Conflict-free: src_get, sink_put, newLen_put, getLen_dwm, giveLen_get
//
// Method: giveLen_get
// Conflict-free: src_get, sink_put, newLen_put, getLen_dwm
// Conflicts: giveLen_get
//
//
// Ports:
// Name                         I/O  size props
// src_get                        O    33 reg
// RDY_src_get                    O     1 reg
// RDY_sink_put                   O     1 reg
// RDY_newLen_put                 O     1 reg
// getLen_dwm                     O     1 reg
// RDY_getLen_dwm                 O     1 const
// giveLen_get                    O     9 reg
// RDY_giveLen_get                O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// sink_put                       I    33 reg
// newLen_put                     I     9 reg
// EN_sink_put                    I     1
// EN_newLen_put                  I     1
// EN_src_get                     I     1
// EN_giveLen_get                 I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMHSender(CLK,
		  RST_N,

		  EN_src_get,
		  src_get,
		  RDY_src_get,

		  sink_put,
		  EN_sink_put,
		  RDY_sink_put,

		  newLen_put,
		  EN_newLen_put,
		  RDY_newLen_put,

		  getLen_dwm,
		  RDY_getLen_dwm,

		  EN_giveLen_get,
		  giveLen_get,
		  RDY_giveLen_get);
  input  CLK;
  input  RST_N;

  // actionvalue method src_get
  input  EN_src_get;
  output [32 : 0] src_get;
  output RDY_src_get;

  // action method sink_put
  input  [32 : 0] sink_put;
  input  EN_sink_put;
  output RDY_sink_put;

  // action method newLen_put
  input  [8 : 0] newLen_put;
  input  EN_newLen_put;
  output RDY_newLen_put;

  // value method getLen_dwm
  output getLen_dwm;
  output RDY_getLen_dwm;

  // actionvalue method giveLen_get
  input  EN_giveLen_get;
  output [8 : 0] giveLen_get;
  output RDY_giveLen_get;

  // signals for module outputs
  wire [32 : 0] src_get;
  wire [8 : 0] giveLen_get;
  wire RDY_getLen_dwm,
       RDY_giveLen_get,
       RDY_newLen_put,
       RDY_sink_put,
       RDY_src_get,
       getLen_dwm;

  // register eopR
  reg eopR;
  wire eopR_D_IN, eopR_EN;

  // register fragLenCnt
  reg [8 : 0] fragLenCnt;
  wire [8 : 0] fragLenCnt_D_IN;
  wire fragLenCnt_EN;

  // register hp
  reg [8 : 0] hp;
  wire [8 : 0] hp_D_IN;
  wire hp_EN;

  // register lenR
  reg [9 : 0] lenR;
  wire [9 : 0] lenR_D_IN;
  wire lenR_EN;

  // register mhV
  reg [32 : 0] mhV;
  wire [32 : 0] mhV_D_IN;
  wire mhV_EN;

  // register mhV_1
  reg [32 : 0] mhV_1;
  wire [32 : 0] mhV_1_D_IN;
  wire mhV_1_EN;

  // register mhV_2
  reg [32 : 0] mhV_2;
  wire [32 : 0] mhV_2_D_IN;
  wire mhV_2_EN;

  // register mhV_3
  reg [32 : 0] mhV_3;
  wire [32 : 0] mhV_3_D_IN;
  wire mhV_3_EN;

  // register mhV_4
  reg [32 : 0] mhV_4;
  wire [32 : 0] mhV_4_D_IN;
  wire mhV_4_EN;

  // register mhV_5
  reg [32 : 0] mhV_5;
  wire [32 : 0] mhV_5_D_IN;
  wire mhV_5_EN;

  // register msgHeadLen
  reg [8 : 0] msgHeadLen;
  wire [8 : 0] msgHeadLen_D_IN;
  wire msgHeadLen_EN;

  // ports of submodule headerF
  wire headerF_CLR, headerF_DEQ, headerF_EMPTY_N, headerF_ENQ, headerF_FULL_N;

  // ports of submodule lenToFHF
  wire [8 : 0] lenToFHF_D_IN, lenToFHF_D_OUT;
  wire lenToFHF_CLR, lenToFHF_DEQ, lenToFHF_EMPTY_N, lenToFHF_ENQ;

  // ports of submodule lengthF
  wire [8 : 0] lengthF_D_IN, lengthF_D_OUT;
  wire lengthF_CLR, lengthF_DEQ, lengthF_EMPTY_N, lengthF_ENQ, lengthF_FULL_N;

  // ports of submodule mesgInF
  wire [32 : 0] mesgInF_D_IN, mesgInF_D_OUT;
  wire mesgInF_CLR, mesgInF_DEQ, mesgInF_EMPTY_N, mesgInF_ENQ, mesgInF_FULL_N;

  // ports of submodule mesgOutF
  wire [32 : 0] mesgOutF_D_IN, mesgOutF_D_OUT;
  wire mesgOutF_CLR,
       mesgOutF_DEQ,
       mesgOutF_EMPTY_N,
       mesgOutF_ENQ,
       mesgOutF_FULL_N;

  // ports of submodule messageF
  wire messageF_CLR,
       messageF_DEQ,
       messageF_EMPTY_N,
       messageF_ENQ,
       messageF_FULL_N;

  // ports of submodule msgDoneF
  wire msgDoneF_CLR, msgDoneF_DEQ, msgDoneF_ENQ;

  // rule scheduling signals
  wire CAN_FIRE_RL_eopR__dreg_update,
       CAN_FIRE_RL_popMhV,
       CAN_FIRE_RL_sndHead,
       CAN_FIRE_RL_sndMesg,
       CAN_FIRE_giveLen_get,
       CAN_FIRE_newLen_put,
       CAN_FIRE_sink_put,
       CAN_FIRE_src_get,
       WILL_FIRE_RL_eopR__dreg_update,
       WILL_FIRE_RL_popMhV,
       WILL_FIRE_RL_sndHead,
       WILL_FIRE_RL_sndMesg,
       WILL_FIRE_giveLen_get,
       WILL_FIRE_newLen_put,
       WILL_FIRE_sink_put,
       WILL_FIRE_src_get;

  // inputs to muxes for submodule ports
  reg [32 : 0] MUX_mesgOutF_enq_1__VAL_1;

  // remaining internal signals
  wire hp_4_EQ_msgHeadLen_5___d73,
       mesgOutF_i_notFull__3_AND_NOT_hp_4_EQ_msgHeadL_ETC___d22;

  // actionvalue method src_get
  assign src_get = mesgOutF_D_OUT ;
  assign RDY_src_get = mesgOutF_EMPTY_N ;
  assign CAN_FIRE_src_get = mesgOutF_EMPTY_N ;
  assign WILL_FIRE_src_get = EN_src_get ;

  // action method sink_put
  assign RDY_sink_put = mesgInF_FULL_N ;
  assign CAN_FIRE_sink_put = mesgInF_FULL_N ;
  assign WILL_FIRE_sink_put = EN_sink_put ;

  // action method newLen_put
  assign RDY_newLen_put = lengthF_FULL_N ;
  assign CAN_FIRE_newLen_put = lengthF_FULL_N ;
  assign WILL_FIRE_newLen_put = EN_newLen_put ;

  // value method getLen_dwm
  assign getLen_dwm = eopR ;
  assign RDY_getLen_dwm = 1'd1 ;

  // actionvalue method giveLen_get
  assign giveLen_get = lenToFHF_D_OUT ;
  assign RDY_giveLen_get = lenToFHF_EMPTY_N ;
  assign CAN_FIRE_giveLen_get = lenToFHF_EMPTY_N ;
  assign WILL_FIRE_giveLen_get = EN_giveLen_get ;

  // submodule headerF
  FIFO20 #(.guarded(32'd1)) headerF(.RST(RST_N),
				    .CLK(CLK),
				    .ENQ(headerF_ENQ),
				    .DEQ(headerF_DEQ),
				    .CLR(headerF_CLR),
				    .FULL_N(headerF_FULL_N),
				    .EMPTY_N(headerF_EMPTY_N));

  // submodule lenToFHF
  FIFO2 #(.width(32'd9), .guarded(32'd1)) lenToFHF(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(lenToFHF_D_IN),
						   .ENQ(lenToFHF_ENQ),
						   .DEQ(lenToFHF_DEQ),
						   .CLR(lenToFHF_CLR),
						   .D_OUT(lenToFHF_D_OUT),
						   .FULL_N(),
						   .EMPTY_N(lenToFHF_EMPTY_N));

  // submodule lengthF
  FIFO2 #(.width(32'd9), .guarded(32'd1)) lengthF(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(lengthF_D_IN),
						  .ENQ(lengthF_ENQ),
						  .DEQ(lengthF_DEQ),
						  .CLR(lengthF_CLR),
						  .D_OUT(lengthF_D_OUT),
						  .FULL_N(lengthF_FULL_N),
						  .EMPTY_N(lengthF_EMPTY_N));

  // submodule mesgInF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) mesgInF(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(mesgInF_D_IN),
						   .ENQ(mesgInF_ENQ),
						   .DEQ(mesgInF_DEQ),
						   .CLR(mesgInF_CLR),
						   .D_OUT(mesgInF_D_OUT),
						   .FULL_N(mesgInF_FULL_N),
						   .EMPTY_N(mesgInF_EMPTY_N));

  // submodule mesgOutF
  FIFO2 #(.width(32'd33), .guarded(32'd1)) mesgOutF(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(mesgOutF_D_IN),
						    .ENQ(mesgOutF_ENQ),
						    .DEQ(mesgOutF_DEQ),
						    .CLR(mesgOutF_CLR),
						    .D_OUT(mesgOutF_D_OUT),
						    .FULL_N(mesgOutF_FULL_N),
						    .EMPTY_N(mesgOutF_EMPTY_N));

  // submodule messageF
  FIFO20 #(.guarded(32'd1)) messageF(.RST(RST_N),
				     .CLK(CLK),
				     .ENQ(messageF_ENQ),
				     .DEQ(messageF_DEQ),
				     .CLR(messageF_CLR),
				     .FULL_N(messageF_FULL_N),
				     .EMPTY_N(messageF_EMPTY_N));

  // submodule msgDoneF
  FIFO20 #(.guarded(32'd1)) msgDoneF(.RST(RST_N),
				     .CLK(CLK),
				     .ENQ(msgDoneF_ENQ),
				     .DEQ(msgDoneF_DEQ),
				     .CLR(msgDoneF_CLR),
				     .FULL_N(),
				     .EMPTY_N());

  // rule RL_sndHead
  assign CAN_FIRE_RL_sndHead =
	     mesgOutF_i_notFull__3_AND_NOT_hp_4_EQ_msgHeadL_ETC___d22 &&
	     headerF_EMPTY_N ;
  assign WILL_FIRE_RL_sndHead = CAN_FIRE_RL_sndHead ;

  // rule RL_popMhV
  assign CAN_FIRE_RL_popMhV = lengthF_EMPTY_N && headerF_FULL_N ;
  assign WILL_FIRE_RL_popMhV = CAN_FIRE_RL_popMhV ;

  // rule RL_sndMesg
  assign CAN_FIRE_RL_sndMesg =
	     mesgOutF_FULL_N && mesgInF_EMPTY_N &&
	     (!mesgInF_D_OUT[32] || messageF_EMPTY_N) &&
	     messageF_EMPTY_N ;
  assign WILL_FIRE_RL_sndMesg = CAN_FIRE_RL_sndMesg && !WILL_FIRE_RL_sndHead ;

  // rule RL_eopR__dreg_update
  assign CAN_FIRE_RL_eopR__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_eopR__dreg_update = 1'd1 ;

  // inputs to muxes for submodule ports
  always@(hp or mhV_5 or mhV or mhV_1 or mhV_2 or mhV_3 or mhV_4)
  begin
    case (hp)
      9'd0: MUX_mesgOutF_enq_1__VAL_1 = mhV;
      9'd1: MUX_mesgOutF_enq_1__VAL_1 = mhV_1;
      9'd2: MUX_mesgOutF_enq_1__VAL_1 = mhV_2;
      9'd3: MUX_mesgOutF_enq_1__VAL_1 = mhV_3;
      9'd4: MUX_mesgOutF_enq_1__VAL_1 = mhV_4;
      default: MUX_mesgOutF_enq_1__VAL_1 =
		   { hp != 9'd5 || mhV_5[32], mhV_5[31:0] };
    endcase
  end

  // register eopR
  assign eopR_D_IN = WILL_FIRE_RL_sndMesg && mesgInF_D_OUT[32] ;
  assign eopR_EN = 1'd1 ;

  // register fragLenCnt
  assign fragLenCnt_D_IN = 9'h0 ;
  assign fragLenCnt_EN = 1'b0 ;

  // register hp
  assign hp_D_IN = hp_4_EQ_msgHeadLen_5___d73 ? 9'd0 : hp + 9'd1 ;
  assign hp_EN = CAN_FIRE_RL_sndHead ;

  // register lenR
  assign lenR_D_IN = 10'h0 ;
  assign lenR_EN = 1'b0 ;

  // register mhV
  assign mhV_D_IN = 33'd0 ;
  assign mhV_EN = CAN_FIRE_RL_popMhV ;

  // register mhV_1
  assign mhV_1_D_IN = 33'd1 ;
  assign mhV_1_EN = CAN_FIRE_RL_popMhV ;

  // register mhV_2
  assign mhV_2_D_IN = 33'd2 ;
  assign mhV_2_EN = CAN_FIRE_RL_popMhV ;

  // register mhV_3
  assign mhV_3_D_IN = 33'd3 ;
  assign mhV_3_EN = CAN_FIRE_RL_popMhV ;

  // register mhV_4
  assign mhV_4_D_IN = 33'd4 ;
  assign mhV_4_EN = CAN_FIRE_RL_popMhV ;

  // register mhV_5
  assign mhV_5_D_IN =
	     { (lengthF_D_OUT == 9'd0) ? 8'd128 : 8'd0,
	       lengthF_D_OUT,
	       16'b0 } ;
  assign mhV_5_EN = CAN_FIRE_RL_popMhV ;

  // register msgHeadLen
  assign msgHeadLen_D_IN = 9'h0 ;
  assign msgHeadLen_EN = 1'b0 ;

  // submodule headerF
  assign headerF_ENQ = lengthF_EMPTY_N && headerF_FULL_N ;
  assign headerF_DEQ = WILL_FIRE_RL_sndHead && hp_4_EQ_msgHeadLen_5___d73 ;
  assign headerF_CLR = 1'b0 ;

  // submodule lenToFHF
  assign lenToFHF_D_IN = 9'h0 ;
  assign lenToFHF_ENQ = 1'b0 ;
  assign lenToFHF_DEQ = EN_giveLen_get ;
  assign lenToFHF_CLR = 1'b0 ;

  // submodule lengthF
  assign lengthF_D_IN = newLen_put ;
  assign lengthF_ENQ = EN_newLen_put ;
  assign lengthF_DEQ = CAN_FIRE_RL_popMhV ;
  assign lengthF_CLR = 1'b0 ;

  // submodule mesgInF
  assign mesgInF_D_IN = sink_put ;
  assign mesgInF_ENQ = EN_sink_put ;
  assign mesgInF_DEQ = WILL_FIRE_RL_sndMesg ;
  assign mesgInF_CLR = 1'b0 ;

  // submodule mesgOutF
  assign mesgOutF_D_IN =
	     WILL_FIRE_RL_sndHead ?
	       MUX_mesgOutF_enq_1__VAL_1 :
	       mesgInF_D_OUT ;
  assign mesgOutF_ENQ = WILL_FIRE_RL_sndHead || WILL_FIRE_RL_sndMesg ;
  assign mesgOutF_DEQ = EN_src_get ;
  assign mesgOutF_CLR = 1'b0 ;

  // submodule messageF
  assign messageF_ENQ = WILL_FIRE_RL_sndHead && hp_4_EQ_msgHeadLen_5___d73 ;
  assign messageF_DEQ = WILL_FIRE_RL_sndMesg && mesgInF_D_OUT[32] ;
  assign messageF_CLR = 1'b0 ;

  // submodule msgDoneF
  assign msgDoneF_ENQ = 1'b0 ;
  assign msgDoneF_DEQ = 1'b0 ;
  assign msgDoneF_CLR = 1'b0 ;

  // remaining internal signals
  assign hp_4_EQ_msgHeadLen_5___d73 = hp == msgHeadLen ;
  assign mesgOutF_i_notFull__3_AND_NOT_hp_4_EQ_msgHeadL_ETC___d22 =
	     mesgOutF_FULL_N &&
	     (!hp_4_EQ_msgHeadLen_5___d73 ||
	      headerF_EMPTY_N && messageF_FULL_N) ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        eopR <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fragLenCnt <= `BSV_ASSIGNMENT_DELAY 9'd1;
	hp <= `BSV_ASSIGNMENT_DELAY 9'd0;
	lenR <= `BSV_ASSIGNMENT_DELAY 10'd170;
	msgHeadLen <= `BSV_ASSIGNMENT_DELAY 9'd5;
      end
    else
      begin
        if (eopR_EN) eopR <= `BSV_ASSIGNMENT_DELAY eopR_D_IN;
	if (fragLenCnt_EN)
	  fragLenCnt <= `BSV_ASSIGNMENT_DELAY fragLenCnt_D_IN;
	if (hp_EN) hp <= `BSV_ASSIGNMENT_DELAY hp_D_IN;
	if (lenR_EN) lenR <= `BSV_ASSIGNMENT_DELAY lenR_D_IN;
	if (msgHeadLen_EN)
	  msgHeadLen <= `BSV_ASSIGNMENT_DELAY msgHeadLen_D_IN;
      end
    if (mhV_EN) mhV <= `BSV_ASSIGNMENT_DELAY mhV_D_IN;
    if (mhV_1_EN) mhV_1 <= `BSV_ASSIGNMENT_DELAY mhV_1_D_IN;
    if (mhV_2_EN) mhV_2 <= `BSV_ASSIGNMENT_DELAY mhV_2_D_IN;
    if (mhV_3_EN) mhV_3 <= `BSV_ASSIGNMENT_DELAY mhV_3_D_IN;
    if (mhV_4_EN) mhV_4 <= `BSV_ASSIGNMENT_DELAY mhV_4_D_IN;
    if (mhV_5_EN) mhV_5 <= `BSV_ASSIGNMENT_DELAY mhV_5_D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    eopR = 1'h0;
    fragLenCnt = 9'h0AA;
    hp = 9'h0AA;
    lenR = 10'h2AA;
    mhV = 33'h0AAAAAAAA;
    mhV_1 = 33'h0AAAAAAAA;
    mhV_2 = 33'h0AAAAAAAA;
    mhV_3 = 33'h0AAAAAAAA;
    mhV_4 = 33'h0AAAAAAAA;
    mhV_5 = 33'h0AAAAAAAA;
    msgHeadLen = 9'h0AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMHSender

